<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beneath The Surface - The Legend of Anthera</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Uncial+Antiqua&display=swap"
        rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Cinzel', serif;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            background: #0a0a0f;
            image-rendering: pixelated;
        }

        /* Title Screen */
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            animation: fadeIn 1s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        #titleScreen h1 {
            font-family: 'Uncial Antiqua', cursive;
            font-size: 4rem;
            color: #ffd700;
            margin-bottom: 10px;
            animation: flicker 3s infinite;
        }

        #titleScreen h2 {
            font-size: 1.5rem;
            color: #8b7355;
            margin-bottom: 50px;
            letter-spacing: 8px;
        }

        @keyframes flicker {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.8;
            }

            52% {
                opacity: 1;
            }

            54% {
                opacity: 0.9;
            }
        }

        .menuBtn {
            font-family: 'Cinzel', serif;
            font-size: 1.2rem;
            padding: 15px 60px;
            margin: 10px;
            background: linear-gradient(180deg, #2a2a3e 0%, #1a1a2e 100%);
            border: 2px solid #ffd700;
            color: #ffd700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .menuBtn:hover {
            background: linear-gradient(180deg, #ffd700 0%, #ff8c00 100%);
            color: #1a1a2e;
            transform: scale(1.05);
        }

        /* Professional Cutscene Overlay - Clean Text Only */
        #cutsceneOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 200;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #cutsceneContent {
            position: relative;
            max-width: 800px;
            padding: 20px;
            background: transparent;
            border: none;
            border-radius: 0;
            box-shadow: none;
        }

        #cutsceneImage {
            display: none;
        }

        #cutsceneText {
            color: #fff;
            font-size: 1.2rem;
            text-align: center;
            max-width: 700px;
            line-height: 1.6;
            padding: 0;
            text-shadow: none;
            font-weight: normal;
            letter-spacing: normal;
            min-height: auto;
            position: relative;
        }

        #cutsceneText::after {
            display: none;
        }

        .speaker-name {
            display: block;
            font-size: 1rem;
            color: #ccc;
            margin-bottom: 10px;
            font-weight: normal;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: none;
        }

        #continuePrompt {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #666;
            font-size: 0.9rem;
            text-align: center;
            background: transparent;
            padding: 10px 20px;
            border-radius: 0;
            border: 1px solid #333;
            backdrop-filter: none;
            animation: none;
        }

        #skipBtn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            padding: 8px 16px;
            background: #333;
            color: #fff;
            border: 1px solid #666;
            border-radius: 0;
            font-family: 'Cinzel', serif;
            font-weight: normal;
            font-size: 0.9rem;
            cursor: pointer;
            transition: none;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: none;
            animation: none;
            backdrop-filter: none;
        }

        #skipBtn:hover {
            background: #555;
            border-color: #888;
            transform: none;
            box-shadow: none;
        }

        /* Clean episode title styling */
        .episode-title {
            font-size: 1.5rem;
            color: #fff;
            text-align: center;
            margin-bottom: 15px;
            font-weight: normal;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: none;
        }

        .episode-subtitle {
            font-size: 1rem;
            color: #ccc;
            text-align: center;
            margin-bottom: 20px;
            font-style: normal;
            letter-spacing: 1px;
        }

        @keyframes glow {
            0% {
                text-shadow: 
                    0 0 30px rgba(255, 215, 0, 0.5),
                    0 0 60px rgba(255, 215, 0, 0.3);
            }
            50% {
                text-shadow: 
                    0 0 40px rgba(255, 215, 0, 0.7),
                    0 0 80px rgba(255, 215, 0, 0.5);
            }
        }

        /* Victory Screen */
        #victory {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #0a0a0f 0%, #1a1a2e 50%, #2a1a0e 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 190;
        }

        .skipLevelBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 8px 16px;
            background: rgba(255, 165, 0, 0.8);
            color: #000;
            border: 2px solid #ffa500;
            border-radius: 6px;
            font-family: 'Cinzel', serif;
            font-weight: 700;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 2px 10px rgba(255, 165, 0, 0.3);
        }

        .skipLevelBtn:hover {
            background: rgba(255, 215, 0, 0.9);
            border-color: #ffd700;
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.5);
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: none;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 50;
            pointer-events: none;
        }

        #healthBar {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #ffd700;
            border-radius: 10px;
            overflow: hidden;
        }

        #healthFill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6666);
            transition: width 0.3s ease;
        }

        #score {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffd700;
            font-size: 1.2rem;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #coins {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffd700;
            font-size: 1.1rem;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #levelInfo {
            color: #ffd700;
            text-align: right;
        }

        #levelInfo h3 {
            font-size: 1rem;
            margin-bottom: 5px;
        }

        #timer {
            font-size: 2rem;
            color: #ff4500;
            display: none;
        }

        /* Cinematic Bars */
        .cinematicBar {
            position: absolute;
            left: 0;
            width: 100%;
            height: 60px;
            background: #000;
            z-index: 150;
            transition: height 0.5s ease;
        }

        #topBar {
            top: 0;
        }

        #bottomBar {
            bottom: 0;
        }

        /* Dialogue Box */
        #dialogueBox {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 900px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            padding: 20px 30px;
            display: none;
            z-index: 160;
        }

        #speakerName {
            color: #ffd700;
            font-size: 1rem;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #dialogueText {
            color: #fff;
            font-size: 1.1rem;
            line-height: 1.6;
        }

        /* Level Complete Screen */
        #levelComplete {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 180;
        }

        #levelComplete h2 {
            font-size: 3rem;
            color: #ffd700;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ff6b00;
        }

        #levelComplete p {
            color: #fff;
            font-size: 1.2rem;
            margin-bottom: 30px;
        }

        /* Skip Confirmation Modal */
        #skipConfirmModal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 190;
        }

        #skipConfirmModal .modalContent {
            background: #333;
            padding: 20px;
            border: 2px solid #ffd700;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        #skipConfirmModal h2 {
            font-size: 2rem;
            color: #ffd700;
            margin-bottom: 10px;
        }

        #skipConfirmModal p {
            color: #fff;
            font-size: 1.1rem;
            margin-bottom: 20px;
        }

        #skipConfirmModal .modalButtons {
            display: flex;
            justify-content: space-between;
            width: 100%;
        }

        #skipConfirmModal .menuBtn {
            padding: 10px 20px;
            background: rgba(255, 165, 0, 0.8);
            color: #000;
            border: 2px solid #ffa500;
            border-radius: 6px;
            font-family: 'Cinzel', serif;
            font-weight: 700;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 2px 10px rgba(255, 165, 0, 0.3);
        }

        #skipConfirmModal .menuBtn:hover {
            background: rgba(255, 215, 0, 0.9);
            border-color: #ffd700;
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(255, 215, 0, 0.5);
        }

        /* Game Over Screen */
        #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(50, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 190;
        }

        #gameOver h2 {
            font-size: 4rem;
            color: #ff0000;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ff0000;
        }

        /* Death Screen */
        #deathScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle at center, rgba(20, 0, 0, 0.95) 0%, rgba(0, 0, 0, 0.98) 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 190;
            animation: fadeIn 1s ease-in;
        }

        .deathContent {
            text-align: center;
            max-width: 600px;
            padding: 40px;
            background: linear-gradient(135deg, rgba(40, 0, 0, 0.8) 0%, rgba(20, 0, 0, 0.9) 100%);
            border: 2px solid rgba(139, 0, 0, 0.5);
            border-radius: 15px;
            box-shadow: 0 0 50px rgba(139, 0, 0, 0.3);
        }

        #deathTitle {
            font-size: 4rem;
            color: #ff3333;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
            animation: pulse 2s infinite;
        }

        #deathMessage {
            font-size: 1.2rem;
            color: #cc6666;
            margin-bottom: 30px;
            line-height: 1.6;
            font-style: italic;
        }

        .deathStats {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            border: 1px solid rgba(139, 0, 0, 0.3);
        }

        .stat {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 1rem;
        }

        .stat:last-child {
            margin-bottom: 0;
        }

        .statLabel {
            color: #999;
        }

        .statValue {
            color: #ffd700;
            font-weight: bold;
        }

        .deathButtons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Victory Screen */
        #victory {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #0a0a0f 0%, #1a1a2e 50%, #2a1a0e 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        #victory h2 {
            font-size: 3rem;
            color: #ffd700;
            margin-bottom: 20px;
            text-shadow: 0 0 30px #ffd700;
        }

        #victory p {
            color: #fff;
            font-size: 1.2rem;
            text-align: center;
            max-width: 600px;
            line-height: 1.8;
            margin-bottom: 30px;
        }

        /* Title Screen */
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            animation: fadeIn 1s ease-out;
        }

        /* Loading Screen */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }

        #loading h3 {
            color: #ffd700;
            margin-bottom: 20px;
        }

        .loadingBar {
            width: 300px;
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
        }

        .loadingFill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ff8c00);
            animation: loading 2s ease-in-out forwards;
        }

        @keyframes loading {
            to {
                width: 100%;
            }
        }

        /* Controls Help */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #666;
            font-size: 0.8rem;
            z-index: 50;
            pointer-events: none;
        }

        /* Puzzle UI */
        #puzzleUI {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffd700;
            font-size: 1rem;
            text-align: center;
            display: none;
            z-index: 50;
        }

        /* Boss Health Bar - Epic Animated Version */
        #bossHealth {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            width: 70%;
            max-width: 600px;
            display: none;
            z-index: 50;
            animation: bossHealthIntro 1s ease-out;
        }

        #bossName {
            color: #ff3333;
            text-align: center;
            margin-bottom: 10px;
            font-size: 1.4rem;
            font-weight: bold;
            text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000;
            animation: bossNameGlow 2s ease-in-out infinite alternate;
            letter-spacing: 2px;
        }

        #bossHealthBar {
            width: 100%;
            height: 25px;
            background: linear-gradient(180deg, #1a0000 0%, #330000 50%, #1a0000 100%);
            border: 3px solid #ff0000;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            box-shadow: 
                0 0 30px rgba(255, 0, 0, 0.5),
                inset 0 0 20px rgba(0, 0, 0, 0.8);
        }

        #bossHealthFill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                #ff0000 0%, 
                #ff3333 25%, 
                #ff6666 50%, 
                #ff3333 75%, 
                #ff0000 100%);
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            animation: healthBarPulse 1.5s ease-in-out infinite;
        }

        #bossHealthFill::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255, 255, 255, 0.3) 50%, 
                transparent 100%);
            animation: healthBarShine 3s linear infinite;
        }

        #bossHealthFill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                90deg,
                transparent,
                transparent 2px,
                rgba(255, 0, 0, 0.3) 2px,
                rgba(255, 0, 0, 0.3) 4px
            );
            animation: healthBarScan 1s linear infinite;
        }

        /* Phase-based health bar colors */
        #bossHealth.phase1 #bossHealthFill {
            background: linear-gradient(90deg, 
                #ff0000 0%, 
                #ff3333 25%, 
                #ff6666 50%, 
                #ff3333 75%, 
                #ff0000 100%);
        }

        #bossHealth.phase2 #bossHealthFill {
            background: linear-gradient(90deg, 
                #ff6600 0%, 
                #ff8833 25%, 
                #ffaa66 50%, 
                #ff8833 75%, 
                #ff6600 100%);
            animation: healthBarPulse 1s ease-in-out infinite;
        }

        #bossHealth.phase3 #bossHealthFill {
            background: linear-gradient(90deg, 
                #ff3333 0%, 
                #ff6666 25%, 
                #ff9999 50%, 
                #ff6666 75%, 
                #ff3333 100%);
            animation: healthBarPulse 0.5s ease-in-out infinite;
        }

        #bossHealth.phase3 #bossName {
            color: #ff6666;
            text-shadow: 0 0 30px #ff0000, 0 0 60px #ff0000;
            animation: bossNameEnraged 0.3s ease-in-out infinite alternate;
        }

        /* Damage flash effect */
        #bossHealth.damageFlash #bossHealthBar {
            border-color: #ffffff;
            box-shadow: 
                0 0 50px rgba(255, 255, 255, 0.8),
                inset 0 0 30px rgba(255, 255, 255, 0.3);
        }

        #bossHealth.damageFlash #bossName {
            color: #ffffff;
            text-shadow: 0 0 30px #ffffff;
        }

        /* Boss health bar animations */
        @keyframes bossHealthIntro {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(50px) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1);
            }
        }

        @keyframes bossNameGlow {
            from {
                text-shadow: 0 0 20px #ff0000, 0 0 40px #ff0000;
            }
            to {
                text-shadow: 0 0 30px #ff0000, 0 0 60px #ff0000, 0 0 80px #ff0000;
            }
        }

        @keyframes bossNameEnraged {
            from {
                transform: scale(1);
                text-shadow: 0 0 30px #ff0000, 0 0 60px #ff0000;
            }
            to {
                transform: scale(1.1);
                text-shadow: 0 0 40px #ff0000, 0 0 80px #ff0000, 0 0 100px #ff0000;
            }
        }

        @keyframes healthBarPulse {
            0%, 100% {
                box-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
            }
            50% {
                box-shadow: 0 0 30px rgba(255, 0, 0, 1);
            }
        }

        @keyframes healthBarShine {
            0% {
                left: -100%;
            }
            100% {
                left: 100%;
            }
        }

        @keyframes healthBarScan {
            0% {
                transform: translateX(0);
            }
            100% {
                transform: translateX(4px);
            }
        }

        /* Health segments for visual feedback */
        .healthSegment {
            position: absolute;
            top: 0;
            width: 2px;
            height: 100%;
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        /* Episode Title */
        #episodeTitle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 170;
            display: none;
        }

        #episodeTitle h2 {
            font-size: 1.5rem;
            color: #888;
            letter-spacing: 5px;
            margin-bottom: 10px;
        }

        #episodeTitle h1 {
            font-family: 'Uncial Antiqua', cursive;
            font-size: 3rem;
            color: #ffd700;
            text-shadow: 0 0 20px #ff6b00;
            animation: fadeIn 0.5s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes fadeOut {
            from {
                opacity: 1;
                transform: scale(1);
            }

            to {
                opacity: 0;
                transform: scale(0.9);
            }
        }

        /* Torch glow effect */
        .torchGlow {
            position: absolute;
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(255, 150, 50, 0.3) 0%, transparent 70%);
            pointer-events: none;
            animation: torchFlicker 0.5s infinite;
        }

        @keyframes torchFlicker {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.8;
                transform: scale(0.95);
            }
        }

        /* Race Position Indicator */
        #racePosition {
            position: absolute;
            top: 80px;
            right: 20px;
            color: #ffd700;
            font-size: 2rem;
            display: none;
            z-index: 50;
        }

        /* Particles container */
        #particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 45;
        }

        /* Modal Styles */
        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 999;
        }

        .modalContent {
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            border: 3px solid #ffd700;
            border-radius: 15px;
            padding: 40px;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
        }

        .modalContent h2 {
            font-family: 'Uncial Antiqua', cursive;
            font-size: 2rem;
            color: #ffd700;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff6b00;
        }

        .modalContent p {
            color: #fff;
            font-size: 1.1rem;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .controlsList {
            margin: 30px 0;
        }

        .controlItem {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .key {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid #ffd700;
        }

        .action {
            color: #fff;
            font-size: 1rem;
        }

        /* Enhanced menu buttons */
        .menuBtn {
            font-family: 'Cinzel', serif;
            font-size: 1.2rem;
            padding: 15px 60px;
            margin: 10px;
            background: linear-gradient(180deg, #2a2a3e 0%, #1a1a2e 100%);
            border: 2px solid #ffd700;
            color: #ffd700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 3px;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .menuBtn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .menuBtn:hover::before {
            left: 100%;
        }

        .menuBtn:hover {
            background: linear-gradient(180deg, #ffd700 0%, #ff8c00 100%);
            color: #1a1a2e;
            transform: scale(1.05);
        }

        /* Enhanced title screen */
        #titleScreen {
            background: linear-gradient(180deg, rgba(10, 10, 15, 0.9) 0%, rgba(26, 26, 46, 0.8) 50%, rgba(22, 33, 62, 0.9) 100%);
            background-size: cover;
            background-position: center;
            background-blend-mode: overlay;
        }

        #titleScreen h1 {
            font-family: 'Uncial Antiqua', cursive;
            font-size: 4rem;
            color: #ffd700;
            margin-bottom: 10px;
            animation: flicker 3s infinite;
        }

        #titleScreen h2 {
            font-size: 1.5rem;
            color: #8b7355;
            margin-bottom: 50px;
            letter-spacing: 8px;
        }

        /* Music Toggle Button */
        #musicToggle {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 9999;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(26, 26, 46, 0.85);
            border: 2px solid rgba(255, 215, 0, 0.5);
            color: #ffd700;
            font-size: 1.3rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            backdrop-filter: blur(4px);
            box-shadow: 0 0 12px rgba(255, 215, 0, 0.15);
        }

        #musicToggle:hover {
            background: rgba(255, 215, 0, 0.2);
            border-color: #ffd700;
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);
        }

        #musicToggle.muted {
            color: #666;
            border-color: rgba(102, 102, 102, 0.5);
        }

        /* Volume Slider */
        #volumeSlider {
            position: fixed;
            top: 65px;
            left: 15px;
            z-index: 9999;
            width: 44px;
            height: 120px;
            background: rgba(26, 26, 46, 0.85);
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 22px;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px 0;
            backdrop-filter: blur(4px);
        }

        #volumeSlider input[type="range"] {
            writing-mode: vertical-lr;
            direction: rtl;
            width: 30px;
            height: 90px;
            accent-color: #ffd700;
            cursor: pointer;
        }

        #musicToggle:hover+#volumeSlider,
        #volumeSlider:hover {
            display: flex;
        }
    </style>
</head>

<body>
    <!-- Music Toggle -->
    <button id="musicToggle" title="Toggle Music">üîä</button>
    <div id="volumeSlider"><input type="range" min="0" max="100" value="40" id="volumeRange"></div>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <!-- Loading Screen -->
        <div id="loading">
            <h3>LOADING...</h3>
            <div class="loadingBar">
                <div class="loadingFill"></div>
            </div>
        </div>

        <!-- Title Screen -->
        <div id="titleScreen" style="display: none;">
            <!-- Main Content -->
            <h1>BENEATH THE SURFACE</h1>
            <h2>THE ANTHERA CHRONICLES</h2>

            <button class="menuBtn" id="startBtn">Begin Journey</button>
            <button class="menuBtn" id="storyBtn">The Story</button>
        </div>

        <!-- Cutscene Overlay -->
        <div id="cutsceneOverlay">
            <div id="cutsceneContent">
                <div id="cutsceneImage"></div>
                <div id="cutsceneText"></div>
            </div>
            <div id="continuePrompt">SPACE: Continue ‚Ä¢ DOUBLE-TAP SPACE: Skip All ‚Ä¢ ESC: Skip ‚Ä¢ CLICK: Continue ‚Ä¢ SKIP
                BUTTON: Skip</div>
            <button id="skipBtn">SKIP</button>
        </div>

        <!-- Cinematic Bars -->
        <div id="topBar" class="cinematicBar" style="height: 0;"></div>
        <div id="bottomBar" class="cinematicBar" style="height: 0;"></div>

        <!-- HUD -->
        <div id="hud" style="display: none;">
            <div id="levelInfo">
                <div id="levelName">EPISODE I</div>
                <div id="levelSubtitle">The Descent</div>
            </div>

            <div id="stats">
                <div id="score">Score: <span id="scoreValue">0</span></div>
                <div id="coins">Coins: <span id="coinsValue">0</span></div>
            </div>

            <div id="health">
                <div id="healthBar">
                    <div id="healthFill"></div>
                </div>
            </div>
        </div>

        <!-- Dialogue Box -->
        <div id="dialogueBox">
            <div id="speakerName"></div>
            <div id="dialogueText"></div>
        </div>

        <!-- Episode Title -->
        <div id="episodeTitle">
            <h2>EPISODE I</h2>
            <h1>The Descent</h1>
        </div>

        <!-- Puzzle UI -->
        <div id="puzzleUI">
            <p id="puzzleHint">Find the ancient switches to unlock the path</p>
        </div>

        <!-- Race Position -->
        <div id="racePosition">1st</div>

        <!-- Boss Health -->
        <div id="bossHealth">
            <div id="bossName">GENERAL RAVANA</div>
            <div id="bossHealthBar">
                <div id="bossHealthFill"></div>
            </div>
        </div>

        <!-- Level Complete -->
        <div id="levelComplete">
            <h2>EPISODE COMPLETE</h2>
            <p id="completeMessage">You have proven your worth, soldier.</p>
            <button class="menuBtn" id="continueBtn">Continue</button>
        </div>

        <!-- Skip Confirmation Modal -->
        <div id="skipConfirmModal" style="display: none;">
            <div class="modalContent">
                <h2>Skip Episode?</h2>
                <p>You will miss out on coins, powerups, and the complete experience.</p>
                <p>Continue anyway?</p>
                <div class="modalButtons">
                    <button class="menuBtn" id="confirmSkip">Yes, Skip</button>
                    <button class="menuBtn" id="cancelSkip">No, Continue Playing</button>
                </div>
            </div>
        </div>

        <!-- Game Over -->
        <div id="gameOver">
            <div class="deathContent">
                <h2 id="deathTitle">FALLEN</h2>
                <p id="deathMessage">The kingdom's hope fades...</p>
                <div class="deathStats">
                    <div class="stat">
                        <span class="statLabel">Episode Reached:</span>
                        <span id="deathLevel" class="statValue">I</span>
                    </div>
                    <div class="stat">
                        <span class="statLabel">Coins Collected:</span>
                        <span id="deathCoins" class="statValue">0</span>
                    </div>
                    <div class="stat">
                        <span class="statLabel">Score Achieved:</span>
                        <span id="deathScore" class="statValue">0</span>
                    </div>
                </div>
                <div class="deathButtons">
                    <button class="menuBtn" id="retryBtn">Rise Again</button>
                    <button class="menuBtn" id="menuBtn">Return to Menu</button>
                </div>
            </div>
        </div>

        <!-- Victory Screen -->
        <div id="victory">
            <h2>üèÜ VICTORY üèÜ</h2>
            <p>Against all odds, you have defeated General Ravana and rescued Queen Sita. The kingdom of Anthera shall
                forever sing of your bravery. From the depths beneath the surface, a hero has risen.</p>
            <button class="menuBtn" id="creditsBtn">The End</button>
        </div>

        <!-- Controls -->
        <div id="controls">
            <p>ARROWS/WASD: Move | SPACE: Jump | E: Interact | SHIFT: Sprint</p>
        </div>

        <!-- Controls Modal -->
        <div id="controlsModal" style="display: none;">
            <div class="modalContent">
                <h2>GAME CONTROLS</h2>
                <div class="controlsList">
                    <div class="controlItem">
                        <span class="key">ARROWS / WASD</span>
                        <span class="action">Move your ant</span>
                    </div>
                    <div class="controlItem">
                        <span class="key">SPACE / W / ‚Üë</span>
                        <span class="action">Jump</span>
                    </div>
                    <div class="controlItem">
                        <span class="key">E</span>
                        <span class="action">Interact with objects</span>
                    </div>
                    <div class="controlItem">
                        <span class="key">SHIFT</span>
                        <span class="action">Sprint (faster movement)</span>
                    </div>
                    <div class="controlItem">
                        <span class="key">X / Z</span>
                        <span class="action">Attack with your weapon</span>
                    </div>
                    <div class="controlItem">
                        <span class="key">SHIFT + S</span>
                        <span class="action">Skip current level</span>
                    </div>
                </div>
                <button class="menuBtn" id="closeControls">Back</button>
            </div>
        </div>

        <!-- About Modal -->
        <div id="aboutModal" style="display: none;">
            <div class="modalContent">
                <h2>ABOUT THE ANTHERA CHRONICLES</h2>
                <p>
                    Embark on an epic underground adventure as a brave worker ant on a mission to save your Queen and
                    colony.
                    Navigate through treacherous tunnels, solve ancient puzzles, and battle rival fire ants in this
                    underground platformer.
                </p>
                <p>
                    Experience a rich story of courage, sacrifice, and the unbreakable spirit of the ant colony.
                    Will you be able to rescue Queen Sita and restore peace to Anthera?
                </p>
                <button class="menuBtn" id="closeAbout">Back</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== MUSIC ENGINE (Web Audio API) ====================
        const MusicEngine = (() => {
            let audioCtx = null;
            let masterGain = null;
            let currentTrack = null;
            let currentTrackName = '';
            let isMuted = false;
            let volume = 0.4;
            let activeOscillators = [];
            let activeIntervals = [];
            let fadeTimeout = null;

            // Musical scales (MIDI note numbers)
            const scales = {
                // Dark minor pentatonic for underground feel
                menuAmbient: [48, 51, 53, 55, 58, 60, 63, 65, 67, 70],
                level1: [36, 39, 41, 43, 46, 48, 51, 53, 55, 58],
                level2: [41, 44, 46, 48, 51, 53, 56, 58, 60, 63],
                level3: [43, 46, 48, 50, 53, 55, 58, 60, 62, 65],
                boss: [36, 39, 40, 43, 46, 48, 51, 52, 55, 58],
                victory: [48, 52, 55, 57, 60, 64, 67, 69, 72, 76],
                gameOver: [36, 39, 41, 42, 46, 48, 51, 53, 54, 58]
            };

            function midiToFreq(midi) {
                return 440 * Math.pow(2, (midi - 69) / 12);
            }

            function ensureContext() {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    masterGain = audioCtx.createGain();
                    masterGain.gain.value = volume;
                    masterGain.connect(audioCtx.destination);
                }
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
            }

            function createReverb(duration = 2, decay = 2) {
                const rate = audioCtx.sampleRate;
                const length = rate * duration;
                const impulse = audioCtx.createBuffer(2, length, rate);
                for (let ch = 0; ch < 2; ch++) {
                    const data = impulse.getChannelData(ch);
                    for (let i = 0; i < length; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
                    }
                }
                const convolver = audioCtx.createConvolver();
                convolver.buffer = impulse;
                return convolver;
            }

            function stopAll() {
                activeOscillators.forEach(o => {
                    try { o.stop(); } catch (e) { }
                });
                activeOscillators = [];
                activeIntervals.forEach(id => clearInterval(id));
                activeIntervals = [];
                if (fadeTimeout) { clearTimeout(fadeTimeout); fadeTimeout = null; }
            }

            // ---- Track: Menu Ambient ----
            function playMenuAmbient() {
                const scale = scales.menuAmbient;
                const reverb = createReverb(3, 1.5);
                reverb.connect(masterGain);

                // Deep drone pad
                const droneGain = audioCtx.createGain();
                droneGain.gain.value = 0.06;
                droneGain.connect(reverb);
                [36, 43].forEach(note => {
                    const osc = audioCtx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = midiToFreq(note);
                    osc.connect(droneGain);
                    osc.start();
                    activeOscillators.push(osc);
                });

                // Slow arpeggiated melody
                const melodyGain = audioCtx.createGain();
                melodyGain.gain.value = 0.03;
                melodyGain.connect(reverb);
                let melodyOsc = null;
                const melodyInterval = setInterval(() => {
                    if (melodyOsc) { try { melodyOsc.stop(); } catch (e) { } }
                    const note = scale[Math.floor(Math.random() * scale.length)];
                    melodyOsc = audioCtx.createOscillator();
                    melodyOsc.type = 'triangle';
                    melodyOsc.frequency.value = midiToFreq(note);
                    const env = audioCtx.createGain();
                    env.gain.setValueAtTime(0.04, audioCtx.currentTime);
                    env.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 2.5);
                    melodyOsc.connect(env);
                    env.connect(reverb);
                    melodyOsc.start();
                    melodyOsc.stop(audioCtx.currentTime + 3);
                    activeOscillators.push(melodyOsc);
                }, 3000);
                activeIntervals.push(melodyInterval);
            }

            // ---- Track: Level Gameplay ----
            function playLevelTrack(levelNum) {
                const scaleKey = levelNum <= 3 ? `level${levelNum}` : 'level1';
                const scale = scales[scaleKey];
                const tempo = [0, 400, 500, 300][levelNum] || 400;
                const reverb = createReverb(2, 2);
                reverb.connect(masterGain);

                // Bass line
                const bassGain = audioCtx.createGain();
                bassGain.gain.value = 0.07;
                bassGain.connect(reverb);
                let bassNoteIdx = 0;
                const bassInterval = setInterval(() => {
                    const osc = audioCtx.createOscillator();
                    osc.type = 'triangle';
                    const note = scale[bassNoteIdx % 3];
                    osc.frequency.value = midiToFreq(note);
                    const env = audioCtx.createGain();
                    env.gain.setValueAtTime(0.08, audioCtx.currentTime);
                    env.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + (tempo / 1000) * 0.8);
                    osc.connect(env);
                    env.connect(reverb);
                    osc.start();
                    osc.stop(audioCtx.currentTime + (tempo / 1000));
                    activeOscillators.push(osc);
                    bassNoteIdx++;
                }, tempo);
                activeIntervals.push(bassInterval);

                // Rhythmic percussion (filtered noise)
                const percInterval = setInterval(() => {
                    const bufferSize = audioCtx.sampleRate * 0.05;
                    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                    const noise = audioCtx.createBufferSource();
                    noise.buffer = buffer;
                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'highpass';
                    filter.frequency.value = 800;
                    const env = audioCtx.createGain();
                    env.gain.setValueAtTime(0.04, audioCtx.currentTime);
                    env.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);
                    noise.connect(filter);
                    filter.connect(env);
                    env.connect(masterGain);
                    noise.start();
                    noise.stop(audioCtx.currentTime + 0.1);
                }, tempo / 2);
                activeIntervals.push(percInterval);

                // Melody layer
                const melodyGain = audioCtx.createGain();
                melodyGain.gain.value = 0.03;
                melodyGain.connect(reverb);
                const melodyInterval = setInterval(() => {
                    const note = scale[Math.floor(Math.random() * scale.length)];
                    const osc = audioCtx.createOscillator();
                    osc.type = Math.random() > 0.5 ? 'sine' : 'triangle';
                    osc.frequency.value = midiToFreq(note);
                    const env = audioCtx.createGain();
                    env.gain.setValueAtTime(0.035, audioCtx.currentTime);
                    env.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.2);
                    osc.connect(env);
                    env.connect(reverb);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 1.5);
                    activeOscillators.push(osc);
                }, tempo * 2);
                activeIntervals.push(melodyInterval);

                // Ambient pad drone
                const padGain = audioCtx.createGain();
                padGain.gain.value = 0.04;
                padGain.connect(reverb);
                const padOsc = audioCtx.createOscillator();
                padOsc.type = 'sine';
                padOsc.frequency.value = midiToFreq(scale[0]);
                padOsc.connect(padGain);
                padOsc.start();
                activeOscillators.push(padOsc);
            }

            // ---- Track: Boss Fight ----
            function playBossTrack() {
                const scale = scales.boss;
                const reverb = createReverb(1.5, 3);
                reverb.connect(masterGain);

                // Aggressive bass pulse
                const bassInterval = setInterval(() => {
                    const osc = audioCtx.createOscillator();
                    osc.type = 'sawtooth';
                    const note = scale[Math.floor(Math.random() * 3)];
                    osc.frequency.value = midiToFreq(note);
                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 400;
                    const env = audioCtx.createGain();
                    env.gain.setValueAtTime(0.07, audioCtx.currentTime);
                    env.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
                    osc.connect(filter);
                    filter.connect(env);
                    env.connect(reverb);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.25);
                    activeOscillators.push(osc);
                }, 250);
                activeIntervals.push(bassInterval);

                // Fast hi-hat percussion
                const hihatInterval = setInterval(() => {
                    const bufferSize = audioCtx.sampleRate * 0.03;
                    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                    const noise = audioCtx.createBufferSource();
                    noise.buffer = buffer;
                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'highpass';
                    filter.frequency.value = 3000;
                    const env = audioCtx.createGain();
                    env.gain.setValueAtTime(0.03, audioCtx.currentTime);
                    env.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.04);
                    noise.connect(filter);
                    filter.connect(env);
                    env.connect(masterGain);
                    noise.start();
                    noise.stop(audioCtx.currentTime + 0.05);
                }, 125);
                activeIntervals.push(hihatInterval);

                // Tension melody
                const melodyInterval = setInterval(() => {
                    const note = scale[Math.floor(Math.random() * scale.length)];
                    const osc = audioCtx.createOscillator();
                    osc.type = 'square';
                    osc.frequency.value = midiToFreq(note + 12);
                    const filter = audioCtx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 2000;
                    const env = audioCtx.createGain();
                    env.gain.setValueAtTime(0.025, audioCtx.currentTime);
                    env.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.4);
                    osc.connect(filter);
                    filter.connect(env);
                    env.connect(reverb);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.5);
                    activeOscillators.push(osc);
                }, 500);
                activeIntervals.push(melodyInterval);

                // Low rumble drone
                const droneOsc = audioCtx.createOscillator();
                droneOsc.type = 'sine';
                droneOsc.frequency.value = midiToFreq(24);
                const droneGain = audioCtx.createGain();
                droneGain.gain.value = 0.06;
                droneOsc.connect(droneGain);
                droneGain.connect(masterGain);
                droneOsc.start();
                activeOscillators.push(droneOsc);
            }

            // ---- Track: Game Over ----
            function playGameOverTrack() {
                const scale = scales.gameOver;
                const reverb = createReverb(4, 1);
                reverb.connect(masterGain);

                // Sad descending notes
                let noteIdx = scale.length - 1;
                const descInterval = setInterval(() => {
                    if (noteIdx < 0) noteIdx = scale.length - 1;
                    const osc = audioCtx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = midiToFreq(scale[noteIdx]);
                    const env = audioCtx.createGain();
                    env.gain.setValueAtTime(0.04, audioCtx.currentTime);
                    env.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 2);
                    osc.connect(env);
                    env.connect(reverb);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 2.5);
                    activeOscillators.push(osc);
                    noteIdx--;
                }, 2000);
                activeIntervals.push(descInterval);

                // Low mourning drone
                const droneOsc = audioCtx.createOscillator();
                droneOsc.type = 'sine';
                droneOsc.frequency.value = midiToFreq(36);
                const droneGain = audioCtx.createGain();
                droneGain.gain.value = 0.05;
                droneOsc.connect(droneGain);
                droneGain.connect(reverb);
                droneOsc.start();
                activeOscillators.push(droneOsc);
            }

            // ---- Track: Victory ----
            function playVictoryTrack() {
                const scale = scales.victory;
                const reverb = createReverb(3, 1.5);
                reverb.connect(masterGain);

                // Triumphant ascending arpeggio
                let noteIdx = 0;
                const arpInterval = setInterval(() => {
                    const osc = audioCtx.createOscillator();
                    osc.type = 'triangle';
                    osc.frequency.value = midiToFreq(scale[noteIdx % scale.length]);
                    const env = audioCtx.createGain();
                    env.gain.setValueAtTime(0.05, audioCtx.currentTime);
                    env.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 1.5);
                    osc.connect(env);
                    env.connect(reverb);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 2);
                    activeOscillators.push(osc);
                    noteIdx++;
                }, 600);
                activeIntervals.push(arpInterval);

                // Bright chord pad
                const padGain = audioCtx.createGain();
                padGain.gain.value = 0.04;
                padGain.connect(reverb);
                [60, 64, 67, 72].forEach(note => {
                    const osc = audioCtx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = midiToFreq(note);
                    osc.connect(padGain);
                    osc.start();
                    activeOscillators.push(osc);
                });
            }

            // ---- Track: Cutscene ----
            function playCutsceneTrack() {
                const scale = scales.menuAmbient;
                const reverb = createReverb(4, 1);
                reverb.connect(masterGain);

                // Very soft atmospheric pad
                const padGain = audioCtx.createGain();
                padGain.gain.value = 0.03;
                padGain.connect(reverb);
                [48, 55].forEach(note => {
                    const osc = audioCtx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = midiToFreq(note);
                    osc.connect(padGain);
                    osc.start();
                    activeOscillators.push(osc);
                });

                // Sparse twinkling notes
                const twinkleInterval = setInterval(() => {
                    const note = scale[Math.floor(Math.random() * scale.length)] + 12;
                    const osc = audioCtx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = midiToFreq(note);
                    const env = audioCtx.createGain();
                    env.gain.setValueAtTime(0.025, audioCtx.currentTime);
                    env.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 3);
                    osc.connect(env);
                    env.connect(reverb);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 3.5);
                    activeOscillators.push(osc);
                }, 4000);
                activeIntervals.push(twinkleInterval);
            }

            // ---- SFX (one-shot sounds, don't interrupt music) ----
            function playSFX(type) {
                if (!audioCtx || isMuted) return;
                ensureContext();

                switch (type) {
                    case 'coin': {
                        // Bright ascending chime
                        const freqs = [880, 1100, 1320];
                        freqs.forEach((f, i) => {
                            const osc = audioCtx.createOscillator();
                            osc.type = 'sine';
                            osc.frequency.value = f;
                            const env = audioCtx.createGain();
                            env.gain.setValueAtTime(0, audioCtx.currentTime + i * 0.06);
                            env.gain.linearRampToValueAtTime(0.12 * volume, audioCtx.currentTime + i * 0.06 + 0.02);
                            env.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + i * 0.06 + 0.25);
                            osc.connect(env);
                            env.connect(audioCtx.destination);
                            osc.start(audioCtx.currentTime + i * 0.06);
                            osc.stop(audioCtx.currentTime + i * 0.06 + 0.3);
                        });
                        break;
                    }
                    case 'powerup': {
                        // Triumphant rising chord burst
                        const chordFreqs = [523, 659, 784, 1047];
                        chordFreqs.forEach((f, i) => {
                            const osc = audioCtx.createOscillator();
                            osc.type = 'triangle';
                            osc.frequency.value = f;
                            const env = audioCtx.createGain();
                            env.gain.setValueAtTime(0, audioCtx.currentTime + i * 0.08);
                            env.gain.linearRampToValueAtTime(0.1 * volume, audioCtx.currentTime + i * 0.08 + 0.03);
                            env.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + i * 0.08 + 0.6);
                            osc.connect(env);
                            env.connect(audioCtx.destination);
                            osc.start(audioCtx.currentTime + i * 0.08);
                            osc.stop(audioCtx.currentTime + i * 0.08 + 0.7);
                        });
                        // Add a shimmer sweep
                        const sweep = audioCtx.createOscillator();
                        sweep.type = 'sine';
                        sweep.frequency.setValueAtTime(400, audioCtx.currentTime);
                        sweep.frequency.exponentialRampToValueAtTime(2000, audioCtx.currentTime + 0.5);
                        const sweepEnv = audioCtx.createGain();
                        sweepEnv.gain.setValueAtTime(0.06 * volume, audioCtx.currentTime);
                        sweepEnv.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
                        sweep.connect(sweepEnv);
                        sweepEnv.connect(audioCtx.destination);
                        sweep.start();
                        sweep.stop(audioCtx.currentTime + 0.6);
                        break;
                    }
                    case 'enemyHit': {
                        // Meaty impact thud
                        const osc = audioCtx.createOscillator();
                        osc.type = 'square';
                        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(60, audioCtx.currentTime + 0.15);
                        const filter = audioCtx.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = 600;
                        const env = audioCtx.createGain();
                        env.gain.setValueAtTime(0.1 * volume, audioCtx.currentTime);
                        env.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
                        osc.connect(filter);
                        filter.connect(env);
                        env.connect(audioCtx.destination);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.25);
                        break;
                    }
                    case 'playerHit': {
                        // Pain buzz
                        const osc = audioCtx.createOscillator();
                        osc.type = 'sawtooth';
                        osc.frequency.setValueAtTime(300, audioCtx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.2);
                        const filter = audioCtx.createBiquadFilter();
                        filter.type = 'lowpass';
                        filter.frequency.value = 800;
                        const env = audioCtx.createGain();
                        env.gain.setValueAtTime(0.08 * volume, audioCtx.currentTime);
                        env.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);
                        osc.connect(filter);
                        filter.connect(env);
                        env.connect(audioCtx.destination);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.35);
                        break;
                    }
                    case 'jump': {
                        // Quick boing
                        const osc = audioCtx.createOscillator();
                        osc.type = 'sine';
                        osc.frequency.setValueAtTime(250, audioCtx.currentTime);
                        osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.1);
                        const env = audioCtx.createGain();
                        env.gain.setValueAtTime(0.07 * volume, audioCtx.currentTime);
                        env.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.15);
                        osc.connect(env);
                        env.connect(audioCtx.destination);
                        osc.start();
                        osc.stop(audioCtx.currentTime + 0.2);
                        break;
                    }
                }
            }

            // ---- Public API ----
            return {
                play(trackName) {
                    if (trackName === currentTrackName) return;
                    ensureContext();
                    stopAll();
                    currentTrackName = trackName;
                    if (isMuted) return;

                    switch (trackName) {
                        case 'menu': playMenuAmbient(); break;
                        case 'level1': playLevelTrack(1); break;
                        case 'level2': playLevelTrack(2); break;
                        case 'level3': playLevelTrack(3); break;
                        case 'boss': playBossTrack(); break;
                        case 'gameOver': playGameOverTrack(); break;
                        case 'victory': playVictoryTrack(); break;
                        case 'cutscene': playCutsceneTrack(); break;
                    }
                },

                sfx(type) {
                    playSFX(type);
                },

                setVolume(v) {
                    volume = Math.max(0, Math.min(1, v));
                    if (masterGain) masterGain.gain.value = isMuted ? 0 : volume;
                },

                toggleMute() {
                    isMuted = !isMuted;
                    if (masterGain) masterGain.gain.value = isMuted ? 0 : volume;
                    if (!isMuted && currentTrackName) {
                        // Restart the track if unmuting
                        const t = currentTrackName;
                        currentTrackName = '';
                        this.play(t);
                    }
                    return isMuted;
                },

                get muted() { return isMuted; },
                get currentVolume() { return volume; }
            };
        })();

        // Music toggle button logic
        document.getElementById('musicToggle').addEventListener('click', () => {
            MusicEngine.ensureContext && MusicEngine.play;
            const muted = MusicEngine.toggleMute();
            const btn = document.getElementById('musicToggle');
            btn.textContent = muted ? 'üîá' : 'üîä';
            btn.classList.toggle('muted', muted);
        });

        document.getElementById('volumeRange').addEventListener('input', (e) => {
            MusicEngine.setVolume(e.target.value / 100);
        });

        // Start music on first user interaction (required by browsers)
        let musicStarted = false;
        function startMusicOnInteraction() {
            if (!musicStarted) {
                musicStarted = true;
                if (currentState === GameState.MENU || currentState === GameState.LOADING) {
                    MusicEngine.play('menu');
                }
            }
        }
        document.addEventListener('click', startMusicOnInteraction, { once: false });
        document.addEventListener('keydown', startMusicOnInteraction, { once: false });

        // ==================== GAME ENGINE ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set canvas size
        function resizeCanvas() {
            canvas.width = Math.min(window.innerWidth, 1280);
            canvas.height = Math.min(window.innerHeight, 720);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ==================== GAME STATE ====================
        const GameState = {
            LOADING: 'loading',
            MENU: 'menu',
            CUTSCENE: 'cutscene',
            PLAYING: 'playing',
            PAUSED: 'paused',
            LEVEL_COMPLETE: 'levelComplete',
            GAME_OVER: 'gameOver',
            VICTORY: 'victory'
        };

        let currentState = GameState.LOADING;
        let currentLevel = 0;
        let gameTime = 0;
        let deltaTime = 0;
        let lastTime = 0;

        // ==================== ASSETS ====================
        const Assets = {
            loaded: false,
            images: {},
            sounds: {}
        };

        // Enhanced underground color palette
        const Colors = {
            background: '#0a0a0f',
            caveDark: '#1a1a2e',
            caveMid: '#2d2d44',
            caveLight: '#3d3d5c',
            rock: '#4a4a6a',
            rockLight: '#5a5a7a',
            soil: '#3a2818',
            soilDark: '#2a1810',
            soilLight: '#4a3828',
            dirt: '#5a4838',
            dirtDark: '#4a3828',
            dirtLight: '#6a5848',
            stone: '#6a6a7a',
            stoneDark: '#4a4a5a',
            stoneLight: '#8a8a9a',
            clay: '#7a4a3a',
            lava: '#ff4500',
            lavaGlow: '#ff6b00',
            crystal: '#00ffff',
            crystalGlow: '#00cccc',
            gold: '#ffd700',
            torch: '#ff9932',
            player: '#4a90d9',
            enemy: '#d94a4a',
            platform: '#3d3d5c',
            spike: '#8b0000',
            water: '#1a4a6a',
            roots: '#4a3a2a',
            moss: '#3a4a3a',
            fungi: '#6a4a6a'
        };

        // ==================== PARTICLE SYSTEM ====================
        class Particle {
            constructor(x, y, vx, vy, color, size, life, gravity = 0) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.color = color;
                this.size = size;
                this.life = life;
                this.maxLife = life;
                this.gravity = gravity;
            }

            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.vy += this.gravity * dt;
                this.life -= dt;
            }

            draw(ctx, camera) {
                const alpha = this.life / this.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x - camera.x, this.y - camera.y, this.size * alpha, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        const particles = [];

        function spawnParticles(x, y, count, color, speed = 100, size = 3, life = 1, gravity = 0) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const vel = Math.random() * speed;
                particles.push(new Particle(
                    x, y,
                    Math.cos(angle) * vel,
                    Math.sin(angle) * vel,
                    color,
                    Math.random() * size + 1,
                    Math.random() * life + 0.5,
                    gravity
                ));
            }
        }

        function updateParticles(dt) {
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update(dt);
                if (particles[i].life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }

        function drawParticles(ctx, camera) {
            particles.forEach(p => p.draw(ctx, camera));
        }

        // ==================== CAMERA ====================
        const camera = {
            x: 0,
            y: 0,
            targetX: 0,
            targetY: 0,
            shake: 0,
            shakeIntensity: 0,

            follow(target, levelWidth, levelHeight) {
                this.targetX = target.x - canvas.width / 2 + target.width / 2;
                this.targetY = target.y - canvas.height / 2 + target.height / 2;

                // Smooth follow
                this.x += (this.targetX - this.x) * 0.1;
                this.y += (this.targetY - this.y) * 0.1;

                // Bounds
                this.x = Math.max(0, Math.min(this.x, levelWidth - canvas.width));
                this.y = Math.max(0, Math.min(this.y, levelHeight - canvas.height));

                // Screen shake
                if (this.shake > 0) {
                    this.x += (Math.random() - 0.5) * this.shakeIntensity;
                    this.y += (Math.random() - 0.5) * this.shakeIntensity;
                    this.shake -= deltaTime;
                }
            },

            addShake(intensity, duration) {
                this.shake = duration;
                this.shakeIntensity = intensity;
            }
        };

        // ==================== INPUT ====================
        const keys = {};
        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (e.code === 'Space') e.preventDefault();

            // Skip cutscene with ESC key
            if (e.code === 'Escape' && currentState === GameState.CUTSCENE) {
                endCutscene();
            }

            // Skip level with Shift+S
            if (e.shiftKey && e.code === 'KeyS' && currentState === GameState.PLAYING) {
                skipCurrentLevel();
            }
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        // ==================== PLAYER ====================
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 32;
                this.height = 48;
                this.vx = 0;
                this.vy = 0;

                // Movement physics
                this.speed = 250;
                this.sprintSpeed = 400;
                this.acceleration = 1800; // Higher acceleration for more responsive control
                this.friction = 2000; // Much higher ground friction to stop quickly
                this.airFriction = 400; // Higher air friction for better air control
                this.jumpForce = -450;
                this.gravity = 1200;

                this.grounded = false;
                this.health = 100;
                this.maxHealth = 100;
                this.invincible = 0;
                this.facing = 1;
                this.animFrame = 0;
                this.animTimer = 0;
                this.attacking = false;
                this.attackTimer = 0;
                this.attackCooldown = 0;
                this.dead = false;
                this.canDoubleJump = true; // Enabled double jump by default
                this.hasDoubleJumped = false;
            }

            update(dt, platforms, hazards, enemies) {
                // Invincibility timer
                if (this.invincible > 0) this.invincible -= dt;
                if (this.attackCooldown > 0) this.attackCooldown -= dt;

                // Input-based acceleration
                let moveX = 0;
                if (keys['ArrowLeft'] || keys['KeyA']) moveX = -1;
                if (keys['ArrowRight'] || keys['KeyD']) moveX = 1;

                const sprinting = keys['ShiftLeft'] || keys['ShiftRight'];
                const currentMaxSpeed = (sprinting ? this.sprintSpeed : this.speed) * powerupEffects.speed;

                // Apply acceleration based on input
                if (moveX !== 0) {
                    // Accelerate in the direction of input
                    this.vx += moveX * this.acceleration * dt;

                    // Limit to max speed
                    if (Math.abs(this.vx) > currentMaxSpeed) {
                        this.vx = Math.sign(this.vx) * currentMaxSpeed;
                    }

                    this.facing = moveX;
                } else {
                    // Apply strong friction when no input for immediate stop
                    const frictionForce = this.grounded ? this.friction : this.airFriction;

                    // More aggressive stopping on ground
                    if (this.grounded) {
                        // Almost instant stop on ground when no input
                        this.vx *= 0.85; // Multiply by 0.85 each frame for quick deceleration
                        if (Math.abs(this.vx) < 5) {
                            this.vx = 0; // Complete stop when very slow
                        }
                    } else {
                        // Less aggressive in air
                        if (Math.abs(this.vx) > 0.1) {
                            const frictionDirection = -Math.sign(this.vx);
                            const frictionAmount = frictionForce * dt;

                            if (Math.abs(this.vx) > frictionAmount) {
                                this.vx += frictionDirection * frictionAmount;
                            } else {
                                this.vx = 0;
                            }
                        } else {
                            this.vx = 0;
                        }
                    }
                }

                // Jump mechanics
                if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && this.grounded) {
                    this.vy = this.jumpForce * powerupEffects.jump;
                    this.grounded = false;
                    this.hasDoubleJumped = false;
                    MusicEngine.sfx('jump');
                    spawnParticles(this.x + this.width / 2, this.y + this.height, 5, Colors.caveMid, 50, 2, 0.3, 200);
                } else if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && this.canDoubleJump && !this.hasDoubleJumped && !this.grounded) {
                    if (!keys['_jumpReleased']) {
                        // Wait for key release
                    } else {
                        this.vy = this.jumpForce * 0.8 * powerupEffects.jump;
                        this.hasDoubleJumped = true;
                        spawnParticles(this.x + this.width / 2, this.y + this.height / 2, 8, Colors.crystal, 80, 2, 0.5, 0);
                    }
                }

                if (!keys['Space'] && !keys['ArrowUp'] && !keys['KeyW']) {
                    keys['_jumpReleased'] = true;
                } else if (this.grounded) {
                    keys['_jumpReleased'] = false;
                }

                // Attack
                if (keys['KeyX'] || keys['KeyZ']) {
                    if (this.attackCooldown <= 0 && !this.attacking) {
                        this.attacking = true;
                        this.attackTimer = 0.3;
                        this.attackCooldown = 0.5;

                        // Shoot bullets in boss fight
                        if (currentLevel === 4) {
                            this.shootBullet();
                        }
                    }
                }

                if (this.attacking) {
                    this.attackTimer -= dt;
                    if (this.attackTimer <= 0) this.attacking = false;
                }

                // Gravity
                this.vy += this.gravity * dt;
                if (this.vy > 800) this.vy = 800;

                // Move X
                this.x += this.vx * dt;
                this.grounded = false;

                // Platform collision X
                for (const p of platforms) {
                    if (this.collides(p)) {
                        if (this.vx > 0) this.x = p.x - this.width;
                        else if (this.vx < 0) this.x = p.x + p.width;
                    }
                }

                // Move Y
                this.y += this.vy * dt;

                // Platform collision Y
                for (const p of platforms) {
                    if (this.collides(p)) {
                        if (this.vy > 0) {
                            this.y = p.y - this.height;
                            this.vy = 0;
                            this.grounded = true;
                            this.hasDoubleJumped = false;
                        } else if (this.vy < 0) {
                            this.y = p.y + p.height;
                            this.vy = 0;
                        }
                    }
                }

                // Hazard collision
                for (const h of hazards) {
                    if (this.collides(h) && this.invincible <= 0) {
                        this.takeDamage(h.damage || 20);
                    }
                }

                // Enemy collision (for attacking)
                if (this.attacking) {
                    const attackBox = {
                        x: this.facing > 0 ? this.x + this.width : this.x - 40,
                        y: this.y,
                        width: 40,
                        height: this.height
                    };
                    for (const e of enemies) {
                        if (this.boxCollides(attackBox, e) && !e.dead) {
                            e.takeDamage(25);
                            camera.addShake(3, 0.1);
                            spawnParticles(e.x + e.width / 2, e.y + e.height / 2, 10, Colors.enemy, 100, 3, 0.5, 100);
                        }
                    }
                }

                // Animation
                this.animTimer += dt;
                if (this.animTimer > 0.1) {
                    this.animTimer = 0;
                    this.animFrame = (this.animFrame + 1) % 4;
                }

                // Running particles
                if (this.grounded && Math.abs(this.vx) > 100) {
                    if (Math.random() < 0.3) {
                        spawnParticles(this.x + this.width / 2, this.y + this.height, 1, Colors.caveMid, 30, 2, 0.3, 100);
                    }
                }
            }

            takeDamage(amount) {
                if (this.invincible > 0) return;
                this.health -= amount;
                this.invincible = 1;
                MusicEngine.sfx('playerHit');
                camera.addShake(5, 0.2);
                spawnParticles(this.x + this.width / 2, this.y + this.height / 2, 15, '#ff0000', 150, 4, 0.5, 200);
                document.getElementById('healthFill').style.width = (this.health / this.maxHealth * 100) + '%';

                if (this.health <= 0) {
                    this.health = 0;
                    gameOver();
                }
            }

            heal(amount) {
                this.health = Math.min(this.maxHealth, this.health + amount);
                document.getElementById('healthFill').style.width = (this.health / this.maxHealth * 100) + '%';
                spawnParticles(this.x + this.width / 2, this.y + this.height / 2, 10, '#00ff00', 80, 3, 0.5, -50);
            }

            shootBullet() {
                let vx = this.facing > 0 ? 400 : -400;
                let vy = 0;

                // Auto-aim at boss if it exists
                const boss = enemies.find(e => e.type === 'boss' && !e.dead);
                if (boss) {
                    const dx = (boss.x + boss.width / 2) - (this.x + this.width / 2);
                    const dy = (boss.y + boss.height / 2) - (this.y + this.height / 2);
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        const speed = 600; // slightly faster bullets for boss fight
                        vx = (dx / dist) * speed;
                        vy = (dy / dist) * speed;
                    }
                }

                // Create player bullet
                const bullet = {
                    x: this.x + this.width / 2,
                    y: this.y + this.height / 2,
                    vx: vx,
                    vy: vy,
                    width: 12,
                    height: 12, // Make it square for easier rotation/visibility
                    damage: 50,
                    lifetime: 2,
                    isPlayerBullet: true
                };

                if (!this.bullets) this.bullets = [];
                this.bullets.push(bullet);

                // Visual effect
                spawnParticles(this.x + this.width / 2, this.y + this.height / 2, 5, '#00ffff', 60, 2, 0.5, 0);
            }

            collides(other) {
                return this.x < other.x + other.width &&
                    this.x + this.width > other.x &&
                    this.y < other.y + other.height &&
                    this.y + this.height > other.y;
            }

            collidesWith(other) {
                return this.x < other.x + other.width &&
                    this.x + this.width > other.x &&
                    this.y < other.y + other.height &&
                    this.y + this.height > other.y;
            }

            boxCollides(a, b) {
                return a.x < b.x + b.width &&
                    a.x + a.width > b.x &&
                    a.y < b.y + b.height &&
                    a.y + a.height > b.y;
            }

            draw(ctx, camera) {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;

                // Flash when invincible
                if (this.invincible > 0 && Math.floor(this.invincible * 10) % 2 === 0) {
                    ctx.globalAlpha = 0.5;
                }

                // Ant body segments - properly aligned horizontally
                const bodyColor = '#2a2a2a';
                const segmentColor = '#1a1a1a';
                const centerX = screenX + this.width / 2; // Proper horizontal center

                // Body bounce animation when grounded
                const bodyBounce = this.grounded ? Math.sin(this.animFrame * 0.2) * 1 : 0;

                // Head (rounded) - centered horizontally
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(centerX, screenY + 8 + bodyBounce, 10, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                // Thorax (middle segment) - centered horizontally
                ctx.fillStyle = segmentColor;
                ctx.beginPath();
                ctx.ellipse(centerX, screenY + 18 + bodyBounce, 8, 6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Abdomen (back segment - larger) - centered horizontally
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(centerX, screenY + 30 + bodyBounce, 12, 10, 0, 0, Math.PI * 2);
                ctx.fill();

                // Antennae - centered on head
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                // Left antenna
                ctx.moveTo(centerX - 4, screenY + 6 + bodyBounce);
                ctx.quadraticCurveTo(centerX - 8, screenY - 2 + bodyBounce, centerX - 6, screenY - 6 + bodyBounce);
                // Right antenna
                ctx.moveTo(centerX + 4, screenY + 6 + bodyBounce);
                ctx.quadraticCurveTo(centerX + 8, screenY - 2 + bodyBounce, centerX + 6, screenY - 6 + bodyBounce);
                ctx.stroke();

                // Eyes - centered on head
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(centerX - 3, screenY + 6 + bodyBounce, 2, 0, Math.PI * 2);
                ctx.arc(centerX + 3, screenY + 6 + bodyBounce, 2, 0, Math.PI * 2);
                ctx.fill();

                // Enhanced 6-legged horizontal ant animation system
                ctx.strokeStyle = bodyColor;
                ctx.lineWidth = 2;

                // More realistic leg movement based on velocity and grounded state
                const moveIntensity = Math.abs(this.vx) > 10 ? Math.abs(this.vx) / 250 : 0;
                const legSpeed = this.grounded ? 0.8 : 0.2; // Faster leg movement when grounded and moving
                const legAmplitude = moveIntensity * 8; // Leg movement amplitude based on speed

                // Calculate leg phases for realistic walking pattern
                const legPhase = this.animFrame * legSpeed;

                // 6-legged ant configuration - 3 per side, arranged horizontally
                // Left legs (front, middle, back)
                const leftLegPositions = [
                    { x: centerX - 10, y: screenY + 10 },  // Front leg
                    { x: centerX - 8, y: screenY + 18 },   // Middle leg  
                    { x: centerX - 6, y: screenY + 26 }    // Back leg
                ];

                // Right legs (front, middle, back)
                const rightLegPositions = [
                    { x: centerX + 10, y: screenY + 10 },  // Front leg
                    { x: centerX + 8, y: screenY + 18 },   // Middle leg
                    { x: centerX + 6, y: screenY + 26 }    // Back leg
                ];

                // Draw left legs with alternating movement pattern
                for (let i = 0; i < 3; i++) {
                    const legPos = leftLegPositions[i];
                    const legPhaseOffset = i * Math.PI / 3; // 120-degree offset for tripod gait
                    const individualLegOffset = Math.sin(legPhase + legPhaseOffset) * legAmplitude;

                    ctx.beginPath();
                    // Leg extends horizontally from body
                    ctx.moveTo(legPos.x, legPos.y + bodyBounce);

                    // Middle joint
                    const midX = legPos.x - 8;
                    const midY = legPos.y + 4 + bodyBounce + individualLegOffset * 0.5;
                    ctx.lineTo(midX, midY);

                    // Foot/ground contact
                    const footX = midX - 6;
                    const footY = midY + 6 + individualLegOffset;
                    ctx.lineTo(footX, footY);

                    ctx.stroke();

                    // Draw foot pad
                    ctx.fillStyle = bodyColor;
                    ctx.beginPath();
                    ctx.ellipse(footX, footY, 2, 1, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw right legs with opposite movement pattern
                for (let i = 0; i < 3; i++) {
                    const legPos = rightLegPositions[i];
                    const legPhaseOffset = i * Math.PI / 3 + Math.PI; // Opposite phase for tripod gait
                    const individualLegOffset = Math.sin(legPhase + legPhaseOffset) * legAmplitude;

                    ctx.beginPath();
                    // Leg extends horizontally from body
                    ctx.moveTo(legPos.x, legPos.y + bodyBounce);

                    // Middle joint
                    const midX = legPos.x + 8;
                    const midY = legPos.y + 4 + bodyBounce + individualLegOffset * 0.5;
                    ctx.lineTo(midX, midY);

                    // Foot/ground contact
                    const footX = midX + 6;
                    const footY = midY + 6 + individualLegOffset;
                    ctx.lineTo(footX, footY);

                    ctx.stroke();

                    // Draw foot pad
                    ctx.fillStyle = bodyColor;
                    ctx.beginPath();
                    ctx.ellipse(footX, footY, 2, 1, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Sword (when attacking)
                if (this.attacking) {
                    ctx.fillStyle = '#8b4513'; // Wooden sword theme
                    ctx.save();
                    ctx.translate(centerX, screenY + this.height / 2);
                    ctx.rotate(this.facing > 0 ? -0.5 + this.attackTimer * 5 : 0.5 - this.attackTimer * 5);
                    ctx.fillRect(0, -2, 30 * this.facing, 4);
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(0, -3, 6 * this.facing, 6);
                    ctx.restore();
                } else {
                    // Sword at rest (small wooden dagger) - positioned correctly
                    ctx.fillStyle = '#8b4513';
                    ctx.fillRect(centerX + (this.facing > 0 ? 12 : -16), screenY + 15 + bodyBounce, 4, 15);
                    ctx.fillStyle = '#654321';
                    ctx.fillRect(centerX + (this.facing > 0 ? 10 : -14), screenY + 13 + bodyBounce, 8, 4);
                }

                ctx.globalAlpha = 1;
            }
        }

        // ==================== ENEMY ====================
        class Enemy {
            constructor(x, y, type = 'soldier') {
                this.x = x;
                this.y = y;
                this.type = type;
                this.width = type === 'boss' ? 64 : 32;
                this.height = type === 'boss' ? 80 : 48;
                this.vx = 0;
                this.vy = 0;
                this.speed = type === 'boss' ? 150 : 80;
                this.health = type === 'boss' ? 500 : 50;
                this.maxHealth = this.health;
                this.gravity = 1200;
                this.grounded = false;
                this.facing = -1;
                this.dead = false;
                this.animFrame = 0;
                this.animTimer = 0;
                this.attackTimer = 0;
                this.attackCooldown = type === 'boss' ? 2 : 1.5;
                this.patrolDir = 1;
                this.patrolTimer = 0;
                this.patrolDuration = 2;
                this.state = 'patrol'; // patrol, chase, attack
                this.detectionRange = type === 'boss' ? 400 : 200;
                this.attackRange = type === 'boss' ? 80 : 50;
                this.damage = type === 'boss' ? 25 : 15;

                // Boss specific
                this.bossPhase = 1;
                this.specialAttackTimer = 0;
                this.moveTimer = 0;
                this.moveDirection = 1;
                this.moveSpeed = this.speed;
                this.enraged = false;
                this.shieldActive = false;
                this.summonTimer = 0;
                this.jumpForce = -400; // For jumping to reach player
            }

            update(dt, player, platforms) {
                if (this.dead) return;

                // Update cooldowns
                this.attackCooldown -= dt;
                this.attackTimer -= dt;
                this.animTimer += dt;

                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);

                // EPIC BOSS AI - GENERAL RAVANA
                if (this.type === 'boss') {
                    this.attackTimer += dt;
                    this.specialAttackTimer += dt;
                    this.moveTimer += dt;

                    // MOVEMENT PATTERNS
                    if (this.moveTimer > 3) {
                        this.moveTimer = 0;
                        this.moveDirection *= -1;
                    }

                    // Phase-based movement
                    if (this.bossPhase === 1) {
                        // Phase 1: Patrol movement
                        this.vx = this.moveDirection * this.moveSpeed;
                        if (this.x < 400 || this.x > 1200) {
                            this.moveDirection *= -1;
                        }
                    } else if (this.bossPhase === 2) {
                        // Phase 2: Aggressive pursuit
                        const dx = player.x - this.x;
                        this.vx = Math.sign(dx) * this.moveSpeed * 1.5;
                    } else if (this.bossPhase === 3) {
                        // Phase 3: Erratic movement
                        this.vx = Math.sin(this.moveTimer * 2) * this.moveSpeed * 2;
                        this.vy = Math.cos(this.moveTimer * 3) * 50;
                    }

                    // ATTACK PATTERNS
                    if (this.attackTimer > 2) {
                        this.attackTimer = 0;
                        this.fixedAttack(player);
                    }

                    // SPECIAL ATTACKS
                    if (this.specialAttackTimer > 5) {
                        this.specialAttackTimer = 0;
                        this.fixedAttack(player);
                        camera.addShake(10, 0.5);
                    }

                    // PHASE TRANSITIONS
                    if (this.health < this.maxHealth * 0.66 && this.bossPhase === 1) {
                        this.bossPhase = 2;
                        this.moveSpeed *= 1.3;
                        camera.addShake(15, 0.8);
                        spawnParticles(this.x + this.width / 2, this.y + this.height / 2, 50, '#ff4500', 300, 8, 1.5, 150);
                    }
                    if (this.health < this.maxHealth * 0.33 && this.bossPhase === 2) {
                        this.bossPhase = 3;
                        this.moveSpeed *= 1.5;
                        camera.addShake(20, 1.0);
                        spawnParticles(this.x + this.width / 2, this.y + this.height / 2, 80, '#ff0000', 400, 10, 2, 200);
                    }
                }

                // Regular enemy logic for non-boss enemies
                if (this.type !== 'boss') {
                    // State machine
                    if (dist < this.attackRange && Math.abs(dy) < 50) {
                        this.state = 'attack';
                    } else if (dist < this.detectionRange) {
                        this.state = 'chase';
                    } else {
                        this.state = 'patrol';
                    }

                    // Behavior
                    switch (this.state) {
                        case 'patrol':
                            this.patrolTimer += dt;
                            if (this.patrolTimer > this.patrolDuration) {
                                this.patrolTimer = 0;
                                this.patrolDir *= -1;
                            }
                            this.vx = this.patrolDir * this.speed * 0.5;
                            this.facing = this.patrolDir;
                            break;

                        case 'chase':
                            const moveX = Math.sign(dx);
                            this.vx = moveX * this.speed;
                            this.facing = moveX;

                            // Try to jump if player is above
                            if (dy < -50 && this.grounded && Math.random() < 0.02) {
                                this.vy = this.jumpForce;
                            }
                            break;

                        case 'attack':
                            this.vx = 0;
                            if (this.attackCooldown <= 0) {
                                player.takeDamage(this.damage);
                                this.attackCooldown = 1.5;
                                spawnParticles(
                                    this.x + this.width / 2 + this.facing * 30,
                                    this.y + this.height / 2,
                                    5, '#ff4444', 80, 3, 0.3, 0
                                );
                            }
                            break;
                    }
                }

                // Gravity
                this.vy += this.gravity * dt;
                if (this.vy > 800) this.vy = 800;

                // Movement
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Platform collision
                this.grounded = false;
                for (const p of platforms) {
                    if (this.collides(p)) {
                        if (this.vy > 0) {
                            this.y = p.y - this.height;
                            this.vy = 0;
                            this.grounded = true;
                        } else if (this.vy < 0) {
                            this.y = p.y + p.height;
                            this.vy = 0;
                        }
                    }
                }

                // Edge detection - reverse direction if about to walk off platform
                if (this.grounded && this.state === 'patrol') {
                    let onEdge = true;
                    for (const p of platforms) {
                        // Check if ground exists ahead
                        const checkX = this.x + (this.patrolDir > 0 ? this.width + 5 : -5);
                        if (checkX >= p.x && checkX <= p.x + p.width &&
                            this.y + this.height >= p.y && this.y + this.height <= p.y + 10) {
                            onEdge = false;
                            break;
                        }
                    }
                    if (onEdge) {
                        this.patrolDir *= -1;
                        this.facing = this.patrolDir;
                        this.patrolTimer = 0;
                    }
                }

                // Animation
                if (this.animTimer > 0.15) {
                    this.animTimer = 0;
                    this.animFrame = (this.animFrame + 1) % 4;
                }
            }

            takeDamage(amount) {
                if (this.dead) return;
                this.health -= amount;
                MusicEngine.sfx('enemyHit');

                if (this.type === 'boss') {
                    const healthPercent = (this.health / this.maxHealth * 100);
                    document.getElementById('bossHealthFill').style.width = healthPercent + '%';
                    
                    // Update phase-based styling
                    const bossHealthElement = document.getElementById('bossHealth');
                    bossHealthElement.className = '';
                    
                    if (this.bossPhase === 1) {
                        bossHealthElement.classList.add('phase1');
                    } else if (this.bossPhase === 2) {
                        bossHealthElement.classList.add('phase2');
                    } else if (this.bossPhase === 3) {
                        bossHealthElement.classList.add('phase3');
                    }
                    
                    // Add damage flash effect
                    bossHealthElement.classList.add('damageFlash');
                    setTimeout(() => {
                        bossHealthElement.classList.remove('damageFlash');
                    }, 200);
                }

                if (this.health <= 0) {
                    this.dead = true;
                    spawnParticles(this.x + this.width / 2, this.y + this.height / 2, 50, '#ff0000', 400, 10, 2, 200);

                    if (this.type === 'boss') {
                        // Epic boss defeated - trigger victory immediately
                        document.getElementById('bossHealth').style.display = 'none';
                        victory();
                    }
                }
            }

            collides(other) {
                return this.x < other.x + other.width &&
                    this.x + this.width > other.x &&
                    this.y < other.y + other.height &&
                    this.y + this.height > other.y;
            }

            draw(ctx, cam) {
                if (this.dead) return;

                const screenX = this.x - cam.x;
                const screenY = this.y - cam.y;

                if (this.type === 'boss') {
                    this.drawBoss(ctx, screenX, screenY);
                } else {
                    this.drawSoldier(ctx, screenX, screenY);
                }
            }

            drawSoldier(ctx, screenX, screenY) {
                // Enemy ant soldier
                const bodyColor = '#4a1a1a'; // Darker red-brown
                const segmentColor = '#3a0a0a';

                // Head (more aggressive looking)
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(screenX + this.width / 2, screenY + 8, 10, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                // Thorax
                ctx.fillStyle = segmentColor;
                ctx.beginPath();
                ctx.ellipse(screenX + this.width / 2, screenY + 18, 8, 6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Abdomen (slightly larger for menacing look)
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(screenX + this.width / 2, screenY + 30, 14, 11, 0, 0, Math.PI * 2);
                ctx.fill();

                // Antennae (more angular)
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(screenX + this.width / 2 - 4, screenY + 6);
                ctx.lineTo(screenX + this.width / 2 - 8, screenY - 4);
                ctx.moveTo(screenX + this.width / 2 + 4, screenY + 6);
                ctx.lineTo(screenX + this.width / 2 + 8, screenY - 4);
                ctx.stroke();

                // Evil red eyes
                ctx.fillStyle = '#ff0000';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 3;
                ctx.beginPath();
                ctx.arc(screenX + this.width / 2 - 3, screenY + 6, 2, 0, Math.PI * 2);
                ctx.arc(screenX + this.width / 2 + 3, screenY + 6, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Legs (armored looking)
                ctx.strokeStyle = bodyColor;
                ctx.lineWidth = 3;

                const legOffset = Math.sin(this.animFrame * Math.PI / 2) * 3;

                // Left legs
                for (let i = 0; i < 3; i++) {
                    const legY = screenY + 12 + i * 8;
                    ctx.beginPath();
                    ctx.moveTo(screenX + 4, legY);
                    ctx.lineTo(screenX - 6, legY + 6 + legOffset);
                    ctx.lineTo(screenX - 4, legY + 12 + legOffset);
                    ctx.stroke();
                }

                // Right legs
                for (let i = 0; i < 3; i++) {
                    const legY = screenY + 12 + i * 8;
                    ctx.beginPath();
                    ctx.moveTo(screenX + this.width - 4, legY);
                    ctx.lineTo(screenX + this.width + 6, legY + 6 - legOffset);
                    ctx.lineTo(screenX + this.width + 4, legY + 12 - legOffset);
                    ctx.stroke();
                }

                // Weapon (spear)
                ctx.fillStyle = '#4a4a4a';
                ctx.fillRect(screenX + (this.facing > 0 ? 26 : -8), screenY + 10, 6, 35);
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(screenX + (this.facing > 0 ? 24 : -6), screenY + 8, 10, 6);
            }

            drawBoss(ctx, screenX, screenY) {
                // Giant ant boss - General Ravana

                // Phase-based glow
                if (this.bossPhase >= 2) {
                    ctx.fillStyle = `rgba(255, ${100 - this.bossPhase * 20}, 0, 0.3)`;
                    ctx.beginPath();
                    ctx.arc(screenX + this.width / 2, screenY + this.height / 2, 80, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Massive ant body
                const bodyColor = '#1a0a0a';
                const segmentColor = '#0f0505';

                // Giant head
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(screenX + this.width / 2, screenY + 15, 20, 16, 0, 0, Math.PI * 2);
                ctx.fill();

                // Crown/helmet
                ctx.fillStyle = '#2a0a0a';
                ctx.fillRect(screenX + this.width / 2 - 25, screenY - 5, 50, 15);
                ctx.fillStyle = Colors.lava;
                ctx.fillRect(screenX + this.width / 2 - 15, screenY - 8, 10, 10);
                ctx.fillRect(screenX + this.width / 2 + 5, screenY - 8, 10, 10);

                // Thorax
                ctx.fillStyle = segmentColor;
                ctx.beginPath();
                ctx.ellipse(screenX + this.width / 2, screenY + 35, 16, 12, 0, 0, Math.PI * 2);
                ctx.fill();

                // Massive abdomen
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(screenX + this.width / 2, screenY + 55, 28, 22, 0, 0, Math.PI * 2);
                ctx.fill();

                // Armor plates on abdomen
                ctx.fillStyle = '#3a1a1a';
                ctx.fillRect(screenX + this.width / 2 - 20, screenY + 45, 40, 8);
                ctx.fillStyle = '#4a2a2a';
                ctx.fillRect(screenX + this.width / 2 - 18, screenY + 47, 36, 4);

                // Giant menacing antennae
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(screenX + this.width / 2 - 8, screenY + 10);
                ctx.lineTo(screenX + this.width / 2 - 20, screenY - 10);
                ctx.moveTo(screenX + this.width / 2 + 8, screenY + 10);
                ctx.lineTo(screenX + this.width / 2 + 20, screenY - 10);
                ctx.stroke();

                // Glowing evil eyes
                ctx.fillStyle = this.bossPhase >= 3 ? '#ff0000' : '#ff6600';
                ctx.shadowColor = ctx.fillStyle;
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(screenX + this.width / 2 - 8, screenY + 12, 4, 0, Math.PI * 2);
                ctx.arc(screenX + this.width / 2 + 8, screenY + 12, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Six powerful legs
                ctx.strokeStyle = bodyColor;
                ctx.lineWidth = 5;

                const legOffset = Math.sin(this.animFrame * Math.PI / 2) * 8;

                // Left legs
                for (let i = 0; i < 3; i++) {
                    const legY = screenY + 20 + i * 15;
                    ctx.beginPath();
                    ctx.moveTo(screenX + 8, legY);
                    ctx.lineTo(screenX - 12, legY + 15 + legOffset);
                    ctx.lineTo(screenX - 8, legY + 30 + legOffset);
                    ctx.stroke();
                }

                // Right legs
                for (let i = 0; i < 3; i++) {
                    const legY = screenY + 20 + i * 15;
                    ctx.beginPath();
                    ctx.moveTo(screenX + this.width - 8, legY);
                    ctx.lineTo(screenX + this.width + 12, legY + 15 - legOffset);
                    ctx.lineTo(screenX + this.width + 8, legY + 30 - legOffset);
                    ctx.stroke();
                }

                // Giant spear weapon
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(screenX + (this.facing > 0 ? 58 : -18), screenY + 5, 12, 80);
                ctx.fillStyle = Colors.lava;
                ctx.fillRect(screenX + (this.facing > 0 ? 56 : -16), screenY + 3, 16, 12);

                // Phase indicator particles
                if (this.bossPhase >= 2 && Math.random() < 0.1) {
                    spawnParticles(
                        this.x + Math.random() * this.width,
                        this.y + this.height,
                        1, Colors.lava, 50, 3, 0.5, -100
                    );
                }
            }

            fixedAttack(player) {
                // Enhanced boss attack patterns
                const attackType = Math.floor(Math.random() * 4);

                switch (attackType) {
                    case 0:
                        // Fire spear volley
                        const dx = player.x - this.x;
                        const dy = player.y - this.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        const spearCount = this.bossPhase >= 2 ? 5 : 3;
                        for (let i = 0; i < spearCount; i++) {
                            const angle = Math.atan2(dy, dx) + (i - spearCount / 2) * 0.3;
                            const spear = {
                                x: this.x + this.width / 2,
                                y: this.y + this.height / 2,
                                vx: Math.cos(angle) * 300,
                                vy: Math.sin(angle) * 300,
                                width: 20,
                                height: 10,
                                damage: 20 + this.bossPhase * 5,
                                lifetime: 4
                            };

                            if (!this.spears) this.spears = [];
                            this.spears.push(spear);
                        }
                        spawnParticles(this.x + this.width / 2, this.y + this.height / 2, 20, '#ff4500', 200, 4, 1, 0);
                        break;

                    case 1:
                        // Ground slam shockwave
                        camera.addShake(15, 0.8);
                        spawnParticles(this.x + this.width / 2, this.y + this.height, 40, '#ff6600', 250, 6, 1.2, 300);

                        // Damage if player is on ground nearby
                        const playerDist = Math.abs(player.x - this.x);
                        if (playerDist < 300 && player.grounded) {
                            player.takeDamage(25 + this.bossPhase * 5);
                        }
                        break;

                    case 2:
                        // Tracking fireballs
                        const fireballCount = this.bossPhase >= 2 ? 4 : 2;
                        for (let i = 0; i < fireballCount; i++) {
                            setTimeout(() => {
                                const fireball = {
                                    x: this.x + this.width / 2,
                                    y: this.y + this.height / 3,
                                    vx: (player.x - this.x) * 0.5,
                                    vy: (player.y - this.y) * 0.5,
                                    width: 25,
                                    height: 25,
                                    damage: 15 + this.bossPhase * 3,
                                    lifetime: 5
                                };

                                if (!this.spears) this.spears = [];
                                this.spears.push(fireball);
                            }, i * 200);
                        }
                        spawnParticles(this.x + this.width / 2, this.y + this.height / 3, 25, '#ff8800', 180, 4, 1, 0);
                        break;

                    case 3:
                        // Flame burst (Phase 3 only)
                        if (this.bossPhase === 3) {
                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                const flame = {
                                    x: this.x + this.width / 2,
                                    y: this.y + this.height / 2,
                                    vx: Math.cos(angle) * 250,
                                    vy: Math.sin(angle) * 250,
                                    width: 30,
                                    height: 30,
                                    damage: 30,
                                    lifetime: 3
                                };

                                if (!this.spears) this.spears = [];
                                this.spears.push(flame);
                            }
                            camera.addShake(20, 1.0);
                            spawnParticles(this.x + this.width / 2, this.y + this.height / 2, 50, '#ff0000', 300, 8, 1.5, 200);
                        }
                        break;
                }
            }
        }

        // ==================== RACER (for level 3) ====================
        class Racer {
            constructor(x, y, speed) {
                this.x = x;
                this.y = y;
                this.width = 32;
                this.height = 48;
                this.vx = 0;
                this.vy = 0;
                this.baseSpeed = speed;
                this.speed = speed;
                this.jumpForce = -450;
                this.gravity = 1200;
                this.grounded = false;
                this.finished = false;
                this.animFrame = 0;
                this.animTimer = 0;
                this.jumpCooldown = 0;
            }

            update(dt, platforms, hazards) {
                if (this.finished) return;

                this.jumpCooldown -= dt;

                // Always move right
                this.vx = this.speed;

                // AI jumping logic
                let shouldJump = false;

                // Check for gaps ahead (look 50 pixels ahead)
                const groundCheckX = this.x + this.width + 50;
                let hasGroundAhead = false;
                for (const p of platforms) {
                    // Check if there's a platform at groundCheckX, at our feet level
                    if (groundCheckX >= p.x && groundCheckX <= p.x + p.width &&
                        this.y + this.height >= p.y && this.y + this.height <= p.y + p.height + 20) {
                        hasGroundAhead = true;
                        break;
                    }
                }
                if (!hasGroundAhead && this.grounded) shouldJump = true;

                // Check for hazards/spikes ahead (simplified)
                for (const h of hazards) {
                    if (h.x > this.x && h.x < this.x + 80 &&
                        h.y > this.y - 50 && h.y < this.y + 50) {
                        shouldJump = true;
                        break;
                    }
                }

                // Check for platforms above to jump to
                for (const p of platforms) {
                    if (p.x > this.x && p.x < this.x + 100 && p.y < this.y - 30 && p.y > this.y - 200) {
                        shouldJump = true;
                        break;
                    }
                }

                if (shouldJump && this.grounded && this.jumpCooldown <= 0) {
                    this.vy = this.jumpForce;
                    this.grounded = false;
                    this.jumpCooldown = 0.5;
                }

                // Gravity
                this.vy += this.gravity * dt;
                if (this.vy > 800) this.vy = 800;

                // Movement
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Platform collision
                this.grounded = false;
                for (const p of platforms) {
                    if (this.collides(p)) {
                        if (this.vy > 0) {
                            // Landing on top
                            if (this.y + this.height - this.vy * dt <= p.y + 10) {
                                this.y = p.y - this.height;
                                this.vy = 0;
                                this.grounded = true;
                            }
                        } else if (this.vy < 0) {
                            // Hitting head on bottom
                            this.y = p.y + p.height;
                            this.vy = 0;
                        }
                    }
                }

                // Safety: if stuck or fell off world, respawn at start
                if (this.y > 1200 || this.x < 0) {
                    this.x = 50;
                    this.y = 400;
                    this.vy = 0;
                }

                // Animation
                this.animTimer += dt;
                if (this.animTimer > 0.08) {
                    this.animTimer = 0;
                    this.animFrame = (this.animFrame + 1) % 4;
                }
            }

            collides(other) {
                return this.x < other.x + other.width &&
                    this.x + this.width > other.x &&
                    this.y < other.y + other.height &&
                    this.y + this.height > other.y;
            }

            draw(ctx, cam) {
                if (this.finished) return;

                const screenX = this.x - cam.x;
                const screenY = this.y - cam.y;

                // Racer ant
                const bodyColor = '#3a1a1a';
                const segmentColor = '#2a0a0a';

                // Head
                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(screenX + this.width / 2, screenY + 8, 8, 6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Body segments
                ctx.fillStyle = segmentColor;
                ctx.beginPath();
                ctx.ellipse(screenX + this.width / 2, screenY + 16, 6, 4, 0, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = bodyColor;
                ctx.beginPath();
                ctx.ellipse(screenX + this.width / 2, screenY + 24, 10, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                // Simple legs
                ctx.strokeStyle = bodyColor;
                ctx.lineWidth = 2;

                const legOffset = Math.sin(this.animFrame * Math.PI / 2) * 4;

                // Left legs
                for (let i = 0; i < 3; i++) {
                    const legY = screenY + 10 + i * 6;
                    ctx.beginPath();
                    ctx.moveTo(screenX + 4, legY);
                    ctx.lineTo(screenX - 2, legY + 6 + legOffset);
                    ctx.stroke();
                }

                // Right legs
                for (let i = 0; i < 3; i++) {
                    const legY = screenY + 10 + i * 6;
                    ctx.beginPath();
                    ctx.moveTo(screenX + this.width - 4, legY);
                    ctx.lineTo(screenX + this.width + 2, legY + 6 - legOffset);
                    ctx.stroke();
                }

                // Antennae
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(screenX + this.width / 2 - 2, screenY + 4);
                ctx.lineTo(screenX + this.width / 2 - 4, screenY - 2);
                ctx.moveTo(screenX + this.width / 2 + 2, screenY + 4);
                ctx.lineTo(screenX + this.width / 2 + 4, screenY - 2);
                ctx.stroke();
            }
        }

        // ==================== INTERACTABLE ====================
        class Interactable {
            constructor(x, y, width, height, type, data = {}) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.type = type;
                this.data = data;
                this.activated = false;
                this.animTimer = 0;
            }

            update(dt, player) {
                this.animTimer += dt;

                // Special handling for pressure plates - automatic activation on collision
                if (this.type === 'pressurePlate') {
                    const isSteppingOn = player.x < this.x + this.width &&
                        player.x + player.width > this.x &&
                        player.y < this.y + this.height &&
                        player.y + player.height > this.y;

                    if (isSteppingOn && !this.activated) {
                        this.activated = true;
                        if (this.data.onActivate) this.data.onActivate();
                        spawnParticles(this.x + this.width / 2, this.y, 8, Colors.gold, 60, 2, 0.5, -20);
                    } else if (!isSteppingOn && this.activated) {
                        this.activated = false;
                    }
                    return;
                }

                // Special handling for crystals - automatic collection
                if (this.type === 'crystal') {
                    if (!this.activated) {
                        const isNearby = player.x < this.x + this.width + 20 &&
                            player.x + player.width > this.x - 20 &&
                            player.y < this.y + this.height + 20 &&
                            player.y + player.height > this.y - 20;

                        if (isNearby) {
                            this.activated = true;
                            player.canDoubleJump = true;
                            if (this.data.onActivate) this.data.onActivate();
                            spawnParticles(this.x + this.width / 2, this.y + this.height / 2, 20, Colors.crystal, 100, 4, 1, 0);
                        }
                    }
                    return;
                }

                // Regular interactable handling
                const inRange = Math.abs(player.x - this.x) < 50 && Math.abs(player.y - this.y) < 50;

                if (inRange && keys['KeyE'] && !this.activated) {
                    this.interact(player);
                }
            }

            interact(player) {
                switch (this.type) {
                    case 'riddle':
                    case 'mathPuzzle':
                    case 'wordPuzzle':
                    case 'logicPuzzle':
                    case 'finalRiddle':
                        if (!this.data.solved && this.data.onActivate) {
                            this.data.onActivate();
                        }
                        break;
                    case 'weakPoint':
                        if (this.activated && player.attacking) {
                            // Hit weak point for massive damage
                            const boss = enemies.find(e => e.type === 'boss');
                            if (boss) {
                                boss.takeDamage(50); // Critical hit damage
                                this.activated = false;
                                spawnParticles(this.x + this.width / 2, this.y + this.height / 2, 20, Colors.gold, 150, 6, 2, 0);
                            }
                        }
                        break;
                    case 'crystalSwitch':
                        if (!this.activated && this.data.onActivate) {
                            this.data.onActivate();
                            spawnParticles(this.x + this.width / 2, this.y + this.height / 2, 15,
                                this.data.color === 'red' ? '#ff4444' :
                                    this.data.color === 'blue' ? '#4444ff' :
                                        this.data.color === 'green' ? '#44ff44' : '#ff44ff',
                                100, 4, 1, 0);
                        }
                        break;
                    case 'lever':
                        this.activated = !this.activated;
                        if (this.data.onActivate) this.data.onActivate(this.activated);
                        spawnParticles(this.x + this.width / 2, this.y, 10, Colors.gold, 80, 3, 0.5, -50);
                        break;
                    case 'health':
                        if (!this.activated) {
                            this.activated = true;
                            player.heal(50);
                        }
                        break;
                    case 'checkpoint':
                        this.activated = true;
                        currentCheckpoint = { x: this.x, y: this.y - 50 };
                        spawnParticles(this.x + this.width / 2, this.y, 15, Colors.gold, 60, 3, 0.8, -30);
                        break;
                    case 'platform':
                        // Platforms are handled in update, not interact
                        break;
                }
            }

            draw(ctx, cam) {
                const screenX = this.x - cam.x;
                const screenY = this.y - cam.y;

                switch (this.type) {
                    case 'riddle':
                    case 'mathPuzzle':
                    case 'wordPuzzle':
                    case 'logicPuzzle':
                    case 'finalRiddle':
                        // Draw puzzle terminal/scroll
                        ctx.fillStyle = '#2a2a2a';
                        ctx.fillRect(screenX, screenY, this.width, this.height);

                        // Border
                        ctx.strokeStyle = this.data.solved ? '#00ff00' : '#ffaa00';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(screenX, screenY, this.width, this.height);

                        // Question mark or checkmark
                        ctx.fillStyle = this.data.solved ? '#00ff00' : '#ffaa00';
                        ctx.font = '20px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(this.data.solved ? '‚úì' : '?', screenX + this.width / 2, screenY + this.height / 2 + 5);

                        // Glow effect when active
                        if (!this.data.solved) {
                            ctx.fillStyle = `rgba(255, 170, 0, ${0.3 + Math.sin(this.animTimer * 3) * 0.2})`;
                            ctx.fillRect(screenX - 5, screenY - 5, this.width + 10, this.height + 10);
                        }
                        break;
                    case 'platform':
                        if (this.visible) {
                            const colors = {
                                red: '#ff4444',
                                blue: '#4444ff',
                                green: '#44ff44'
                            };
                            const color = colors[this.data.color] || '#ffffff';

                            // Draw glowing platform
                            ctx.fillStyle = `${color}88`;
                            ctx.fillRect(screenX, screenY, this.width, this.height);

                            // Add glow effect
                            ctx.shadowColor = color;
                            ctx.shadowBlur = 10;
                            ctx.strokeStyle = color;
                            ctx.lineWidth = 2;
                            ctx.strokeRect(screenX, screenY, this.width, this.height);
                            ctx.shadowBlur = 0;
                        }
                        break;
                    case 'weakPoint':
                        if (this.activated) {
                            // Glowing weak point
                            ctx.fillStyle = `rgba(255, 215, 0, ${0.5 + Math.sin(this.animTimer * 8) * 0.3})`;
                            ctx.beginPath();
                            ctx.arc(screenX + this.width / 2, screenY + this.height / 2, 20, 0, Math.PI * 2);
                            ctx.fill();

                            // Inner core
                            ctx.fillStyle = '#ffffff';
                            ctx.beginPath();
                            ctx.arc(screenX + this.width / 2, screenY + this.height / 2, 8, 0, Math.PI * 2);
                            ctx.fill();
                        } else {
                            // Hidden weak point
                            ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
                            ctx.fillRect(screenX, screenY, this.width, this.height);
                        }
                        break;
                    case 'crystalSwitch':
                        if (this.activated) return;

                        // Draw crystal with color
                        const colors = {
                            red: '#ff4444',
                            blue: '#4444ff',
                            green: '#44ff44'
                        };
                        const color = colors[this.data.color] || '#ffffff';

                        // Glow effect
                        ctx.fillStyle = `${color}33`;
                        ctx.beginPath();
                        ctx.arc(screenX + this.width / 2, screenY + this.height / 2, 25, 0, Math.PI * 2);
                        ctx.fill();

                        // Crystal
                        ctx.fillStyle = this.activated ? color : `${color}88`;
                        ctx.beginPath();
                        ctx.moveTo(screenX + this.width / 2, screenY);
                        ctx.lineTo(screenX + this.width, screenY + this.height * 0.7);
                        ctx.lineTo(screenX + this.width / 2, screenY + this.height);
                        ctx.lineTo(screenX, screenY + this.height * 0.7);
                        ctx.closePath();
                        ctx.fill();

                        // Inner light
                        if (this.activated) {
                            ctx.fillStyle = `${color}ff`;
                            ctx.beginPath();
                            ctx.arc(screenX + this.width / 2, screenY + this.height / 2, 5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                    case 'lever':
                        // Base
                        ctx.fillStyle = Colors.rock;
                        ctx.fillRect(screenX, screenY + 20, 20, 20);
                        // Handle
                        ctx.fillStyle = this.activated ? Colors.gold : '#666';
                        ctx.save();
                        ctx.translate(screenX + 10, screenY + 20);
                        ctx.rotate(this.activated ? 0.5 : -0.5);
                        ctx.fillRect(-3, -25, 6, 25);
                        ctx.restore();
                        break;

                    case 'crystal':
                        if (this.activated) return;
                        // Glow
                        ctx.fillStyle = `rgba(0, 255, 255, ${0.2 + Math.sin(this.animTimer * 3) * 0.1})`;
                        ctx.beginPath();
                        ctx.arc(screenX + this.width / 2, screenY + this.height / 2, 30, 0, Math.PI * 2);
                        ctx.fill();
                        // Crystal shape
                        ctx.fillStyle = Colors.crystal;
                        ctx.beginPath();
                        ctx.moveTo(screenX + this.width / 2, screenY);
                        ctx.lineTo(screenX + this.width, screenY + this.height * 0.7);
                        ctx.lineTo(screenX + this.width / 2, screenY + this.height);
                        ctx.lineTo(screenX, screenY + this.height * 0.7);
                        ctx.closePath();
                        ctx.fill();
                        break;

                    case 'health':
                        if (this.activated) return;
                        ctx.fillStyle = '#00ff00';
                        ctx.fillRect(screenX + 8, screenY, 8, 24);
                        ctx.fillRect(screenX, screenY + 8, 24, 8);
                        break;

                    case 'checkpoint':
                        // Flag pole
                        ctx.fillStyle = this.activated ? Colors.gold : '#666';
                        ctx.fillRect(screenX + 10, screenY, 4, 50);
                        // Flag
                        ctx.fillStyle = this.activated ? Colors.gold : '#888';
                        ctx.beginPath();
                        ctx.moveTo(screenX + 14, screenY);
                        ctx.lineTo(screenX + 34, screenY + 10);
                        ctx.lineTo(screenX + 14, screenY + 20);
                        ctx.closePath();
                        ctx.fill();
                        break;

                    case 'door':
                        ctx.fillStyle = this.activated ? Colors.caveDark : '#4a3a2a';
                        ctx.fillRect(screenX, screenY, this.width, this.height);
                        if (!this.activated) {
                            ctx.fillStyle = Colors.gold;
                            ctx.fillRect(screenX + this.width - 8, screenY + this.height / 2 - 4, 6, 8);
                        }
                        break;

                    case 'pressurePlate':
                        ctx.fillStyle = this.activated ? Colors.gold : Colors.rock;
                        ctx.fillRect(screenX, screenY + (this.activated ? 5 : 0), this.width, 10);
                        break;
                }
            }
        }

        // ==================== COIN CLASS ====================
        class Coin {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 20;
                this.height = 20;
                this.collected = false;
                this.animFrame = 0;
                this.floatOffset = Math.random() * Math.PI * 2;
            }

            update(dt) {
                this.animFrame += dt * 3;
                // Magnet effect
                if (powerupEffects.magnet && !this.collected) {
                    const dx = player.x + player.width / 2 - (this.x + this.width / 2);
                    const dy = player.y + player.height / 2 - (this.y + this.height / 2);
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < 100 && dist > 0) {
                        const pullForce = 300 / dist;
                        this.x += (dx / dist) * pullForce * dt;
                        this.y += (dy / dist) * pullForce * dt;
                    }
                }
            }

            draw(ctx, camera) {
                if (this.collected) return;

                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y + Math.sin(this.animFrame + this.floatOffset) * 5;

                // Coin glow
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 10;

                // Coin body
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(screenX + this.width / 2, screenY + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();

                // Coin detail
                ctx.fillStyle = '#ffed4e';
                ctx.beginPath();
                ctx.arc(screenX + this.width / 2, screenY + this.height / 2, this.width / 3, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0;
            }

            collect() {
                if (!this.collected) {
                    this.collected = true;
                    coinsCollected++;
                    score += 100;
                    MusicEngine.sfx('coin');
                    updateHUD();
                    spawnParticles(this.x + this.width / 2, this.y + this.height / 2, 8, '#ffd700', 100, 3, 0.5, 0);
                }
            }
        }

        // ==================== POWERUP CLASS ====================
        class Powerup {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 24;
                this.height = 24;
                this.type = type; // 'speed', 'jump', 'magnet', 'health'
                this.collected = false;
                this.animFrame = 0;
                this.floatOffset = Math.random() * Math.PI * 2;
            }

            update(dt) {
                this.animFrame += dt * 2;
            }

            draw(ctx, camera) {
                if (this.collected) return;

                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y + Math.sin(this.animFrame + this.floatOffset) * 3;

                // Powerup glow based on type
                const colors = {
                    speed: '#00ff00',
                    jump: '#00ffff',
                    magnet: '#ff00ff',
                    health: '#ff4444'
                };

                ctx.shadowColor = colors[this.type];
                ctx.shadowBlur = 15;

                // Powerup container
                ctx.fillStyle = colors[this.type];
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(screenX + this.width / 2, screenY + this.height / 2, this.width / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();

                // Powerup icon
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const icons = {
                    speed: '‚ö°',
                    jump: 'üöÄ',
                    magnet: 'üß≤',
                    health: '‚ù§Ô∏è'
                };

                ctx.fillText(icons[this.type], screenX + this.width / 2, screenY + this.height / 2);

                ctx.shadowBlur = 0;
            }

            collect() {
                if (!this.collected) {
                    this.collected = true;
                    score += 250;
                    this.applyEffect();
                    MusicEngine.sfx('powerup');
                    updateHUD();
                    spawnParticles(this.x + this.width / 2, this.y + this.height / 2, 12, '#00ff00', 150, 4, 0.8, 0);
                }
            }

            applyEffect() {
                switch (this.type) {
                    case 'speed':
                        powerupEffects.speed = 1.5;
                        setTimeout(() => powerupEffects.speed = 1, 10000);
                        break;
                    case 'jump':
                        powerupEffects.jump = 1.3;
                        setTimeout(() => powerupEffects.jump = 1, 10000);
                        break;
                    case 'magnet':
                        powerupEffects.magnet = true;
                        setTimeout(() => powerupEffects.magnet = false, 15000);
                        break;
                    case 'health':
                        player.heal(25);
                        break;
                }
            }
        }

        // ==================== FINISH FLAG CLASS ====================
        class FinishFlag {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 40;
                this.height = 60;
                this.animFrame = 0;
                this.reached = false;
            }

            update(dt) {
                this.animFrame += dt * 2;
            }

            draw(ctx, camera) {
                const screenX = this.x - camera.x;
                const screenY = this.y - camera.y;

                // Flag pole
                ctx.fillStyle = '#8b4513';
                ctx.fillRect(screenX + this.width / 2 - 2, screenY, 4, this.height);

                // Flag
                ctx.fillStyle = this.reached ? '#00ff00' : '#ff4444';
                ctx.beginPath();
                ctx.moveTo(screenX + this.width / 2 + 2, screenY + 5);
                ctx.lineTo(screenX + this.width / 2 + 2 + 20 + Math.sin(this.animFrame) * 3, screenY + 15);
                ctx.lineTo(screenX + this.width / 2 + 2, screenY + 25);
                ctx.closePath();
                ctx.fill();

                // Flag star
                if (!this.reached) {
                    ctx.fillStyle = '#ffffff';
                    ctx.font = '16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('‚≠ê', screenX + this.width / 2 + 12, screenY + 18);
                }
            }

            checkReach(player) {
                if (!this.reached && this.collides(player)) {
                    this.reached = true;
                    score += 500;
                    updateHUD();
                    levelComplete();
                    return true;
                }
                return false;
            }

            collides(other) {
                return this.x < other.x + other.width &&
                    this.x + this.width > other.x &&
                    this.y < other.y + other.height &&
                    this.y + this.height > other.y;
            }
        }

        // ==================== UPDATE HUD ====================
        function updateHUD() {
            document.getElementById('scoreValue').textContent = score;
            document.getElementById('coinsValue').textContent = coinsCollected;
        }

        // ==================== LEVEL DATA ====================
        let player;
        let platforms = [];
        let hazards = [];
        let enemies = [];
        let interactables = [];
        let racers = [];
        let coins = [];
        let powerups = [];
        let finishFlag = null;
        let levelWidth = 0;
        let levelHeight = 0;
        let currentCheckpoint = null;

        // Game state
        let score = 0;
        let coinsCollected = 0;
        let powerupEffects = {
            speed: 1,
            jump: 1,
            magnet: false
        };
        let levelGoal = null;
        let raceTimer = 0;
        let puzzlesSolved = 0;
        let puzzlesRequired = 0;

        function createLevel(levelNum) {
            platforms = [];
            hazards = [];
            enemies = [];
            interactables = [];
            racers = [];
            coins = [];
            powerups = [];
            finishFlag = null;

            // Reset powerup effects
            powerupEffects.speed = 1;
            powerupEffects.jump = 1;
            powerupEffects.magnet = false;
            particles.length = 0;
            puzzlesSolved = 0;

            switch (levelNum) {
                case 1:
                    createLevel1();
                    break;
                case 2:
                    createLevel2();
                    break;
                case 3:
                    createLevel3();
                    break;
                case 4:
                    createBossFight();
                    break;
            }
        }

        function createLevel1() {
            // Episode 1: The Descent - Moderate Challenge
            levelWidth = 3000;
            levelHeight = 800;

            player = new Player(100, 300);
            currentCheckpoint = { x: 100, y: 300 };
            levelGoal = { x: 2800, y: 300, width: 50, height: 100 };

            // Starting platform
            addPlatform(0, 400, 150, 50);

            // First challenge - small gaps
            addPlatform(200, 380, 80, 20);
            addPlatform(330, 360, 70, 20);
            addPlatform(450, 340, 60, 20);
            addPlatform(560, 320, 60, 20);

            // First enemy - easy to avoid
            enemies.push(new Enemy(300, 250, 'soldier'));

            // Safe checkpoint area
            addPlatform(700, 300, 120, 20);
            interactables.push(new Interactable(750, 250, 24, 50, 'checkpoint'));
            interactables.push(new Interactable(780, 250, 24, 24, 'health'));

            // Medium challenge - wider gaps
            addPlatform(900, 320, 80, 20);
            addPlatform(1030, 300, 70, 20);
            addPlatform(1150, 280, 60, 20);

            // Second enemy - patrol area
            enemies.push(new Enemy(1050, 200, 'soldier'));

            // Small spike challenge - easy to jump over
            addPlatform(1300, 320, 100, 20);
            addHazard(1320, 300, 60, 20, 'spikes');
            addPlatform(1450, 340, 80, 20);

            // Third enemy - near spikes
            enemies.push(new Enemy(1400, 250, 'soldier'));

            // Rest area with health
            addPlatform(1600, 360, 150, 20);
            interactables.push(new Interactable(1650, 310, 24, 24, 'health'));
            interactables.push(new Interactable(1680, 310, 24, 24, 'health'));

            // Jump challenge - floating platforms
            addPlatform(1800, 320, 50, 15);
            addPlatform(1900, 280, 50, 15);
            addPlatform(2000, 240, 50, 15);
            addPlatform(2100, 280, 60, 20);

            // Fourth enemy - in jump section
            enemies.push(new Enemy(1950, 150, 'soldier'));

            // Final checkpoint
            addPlatform(2250, 340, 120, 20);
            interactables.push(new Interactable(2300, 290, 24, 50, 'checkpoint'));

            // Final approach - some gaps
            addPlatform(2400, 360, 80, 20);
            addPlatform(2520, 380, 70, 20);
            addPlatform(2630, 400, 80, 20);
            addPlatform(2750, 420, 100, 20);

            // Final enemy before goal
            enemies.push(new Enemy(2600, 320, 'soldier'));

            // Goal area
            addPlatform(2900, 450, 100, 50);

            // Health pickups - strategic placement
            interactables.push(new Interactable(380, 310, 24, 24, 'health'));
            interactables.push(new Interactable(1200, 230, 24, 24, 'health'));
            interactables.push(new Interactable(2100, 190, 24, 24, 'health'));
            interactables.push(new Interactable(2800, 400, 24, 24, 'health'));

            // Helpful powerups
            powerups.push(new Powerup(450, 330, 'health'));
            powerups.push(new Powerup(1150, 250, 'speed'));
            powerups.push(new Powerup(2000, 190, 'jump'));

            // Coins - some in challenging spots
            // Starting area
            for (let i = 0; i < 6; i++) {
                coins.push(new Coin(30 + i * 20, 350));
            }

            // Platform coins
            coins.push(new Coin(250, 330));
            coins.push(new Coin(380, 310));
            coins.push(new Coin(500, 290));
            coins.push(new Coin(750, 250));

            coins.push(new Coin(950, 270));
            coins.push(new Coin(1100, 250));
            coins.push(new Coin(1380, 290)); // Near spikes
            coins.push(new Coin(1700, 310));

            // Jump challenge coins
            coins.push(new Coin(1820, 270));
            coins.push(new Coin(1920, 230));
            coins.push(new Coin(2020, 190));

            // Final section coins
            coins.push(new Coin(2450, 330));
            coins.push(new Coin(2570, 350));
            coins.push(new Coin(2700, 390));
            coins.push(new Coin(2950, 420));

            // Add finish flag
            finishFlag = new FinishFlag(2950, 400);
        }

        function createLevel2() {
            // Episode 2: The Crystal Riddles - Verbal puzzles only
            levelWidth = 1400;
            levelHeight = 600;
            puzzlesRequired = 4;
            puzzlesSolved = 0; // Reset puzzle progress

            player = new Player(100, 400);
            currentCheckpoint = { x: 100, y: 400 };

            // Main floor platform
            addPlatform(0, 500, 1400, 100);

            // Puzzle 1: Easy Ant Quiz
            const riddle1 = new Interactable(200, 460, 60, 40, 'riddle', {
                question: " EASY ANT QUIZ 1 \n\nHow many legs do ants have?\n\n All insects have the same number of legs!",
                answer: "6",
                solved: false
            });
            const door1 = new Interactable(400, 400, 50, 100, 'door');

            riddle1.data.onActivate = () => {
                const answer = prompt(riddle1.data.question);
                if (answer && answer.toLowerCase().trim() === riddle1.data.answer) {
                    riddle1.data.solved = true;
                    door1.activated = true;
                    puzzlesSolved++;
                    updatePuzzleUI();
                    spawnParticles(425, 350, 20, Colors.gold, 100, 5, 1, -50);
                } else {
                    spawnParticles(230, 480, 10, Colors.spike, 80, 3, 0.5, 100);
                }
            };

            interactables.push(riddle1, door1);

            // Puzzle 2: Ant Colony Math
            const mathPuzzle = new Interactable(600, 460, 60, 40, 'mathPuzzle', {
                question: " EASY ANT QUIZ 2 \n\nIf one ant can carry 10 times its weight, how many ants are needed to carry 100 crumbs?\n\n Each ant carries 10 crumbs!",
                answer: "10",
                hint: "100 crumbs √∑ 10 crumbs per ant = 10 ants!",
                solved: false
            });
            const door2 = new Interactable(800, 400, 50, 100, 'door');

            mathPuzzle.data.onActivate = () => {
                const answer = prompt(mathPuzzle.data.question + "\n\nHint: " + mathPuzzle.data.hint);
                if (answer && answer.toLowerCase().trim() === mathPuzzle.data.answer) {
                    mathPuzzle.data.solved = true;
                    door2.activated = true;
                    puzzlesSolved++;
                    updatePuzzleUI();
                    spawnParticles(825, 350, 20, Colors.gold, 100, 5, 1, -50);
                } else {
                    spawnParticles(630, 480, 10, Colors.spike, 80, 3, 0.5, 100);
                }
            };

            interactables.push(mathPuzzle, door2);

            // Checkpoint
            interactables.push(new Interactable(500, 450, 24, 50, 'checkpoint'));

            // Puzzle 3: Ant Fun Facts
            const logicPuzzle = new Interactable(1000, 460, 60, 40, 'logicPuzzle', {
                question: " EASY ANT QUIZ 3 \n\nWhat do ants use to communicate with each other?\n\n They leave chemical trails for other ants to follow!",
                answer: "smell",
                hint: "Think about how ants follow each other in lines!",
                solved: false
            });
            const door3 = new Interactable(1200, 400, 50, 100, 'door');

            logicPuzzle.data.onActivate = () => {
                const answer = prompt(logicPuzzle.data.question + "\n\nHint: " + logicPuzzle.data.hint);
                if (answer && answer.toLowerCase().trim() === logicPuzzle.data.answer) {
                    logicPuzzle.data.solved = true;
                    door3.activated = true;
                    puzzlesSolved++;
                    updatePuzzleUI();
                    spawnParticles(1225, 350, 20, Colors.gold, 100, 5, 1, -50);
                } else {
                    spawnParticles(1030, 480, 10, Colors.spike, 80, 3, 0.5, 100);
                }
            };

            interactables.push(logicPuzzle, door3);

            // Puzzle 4: Final Ant Challenge
            const finalRiddle = new Interactable(1300, 460, 60, 40, 'finalRiddle', {
                question: " FINAL ANT CHALLENGE \n\nWhat is the leader of an ant colony called?\n\n She lays all the eggs for the colony!",
                answer: "queen",
                hint: "Just like Queen Sita in our story!",
                solved: false
            });
            const finalDoor = new Interactable(1350, 400, 50, 100, 'door');

            finalRiddle.data.onActivate = () => {
                if (puzzlesSolved >= 3) {
                    const answer = prompt(finalRiddle.data.question + "\n\nHint: " + finalRiddle.data.hint);
                    if (answer && answer.toLowerCase().trim() === finalRiddle.data.answer) {
                        finalRiddle.data.solved = true;
                        finalDoor.activated = true;
                        puzzlesSolved++;
                        updatePuzzleUI();
                        spawnParticles(1375, 350, 30, Colors.gold, 150, 8, 2, -50);
                    } else {
                        spawnParticles(1330, 480, 10, Colors.spike, 80, 3, 0.5, 100);
                    }
                } else {
                    spawnParticles(1330, 480, 10, Colors.spike, 80, 3, 0.5, 100);
                }
            };

            interactables.push(finalRiddle, finalDoor);

            // Health pickups
            interactables.push(new Interactable(300, 430, 24, 24, 'health'));
            interactables.push(new Interactable(700, 430, 24, 24, 'health'));
            interactables.push(new Interactable(1100, 430, 24, 24, 'health'));

            // Exit
            levelGoal = { x: 1350, y: 400, width: 50, height: 100 };

            // Decorative elements
            interactables.push(new Interactable(50, 470, 20, 30, 'crystalSwitch', { color: 'purple', activated: true }));

            updatePuzzleHint();
        }

        function createLevel3() {
            // Episode 3: The Combat Race - Race to finish with combat
            levelWidth = 2500;
            levelHeight = 600;
            raceTimer = 0;

            player = new Player(50, 400);
            levelGoal = { x: 2400, y: 300, width: 100, height: 200 };

            // Create combat racers with AI
            racers.push(new Racer(50, 400, 160));
            racers.push(new Racer(50, 400, 140));

            // Combat race track with enemy encounters
            // Starting area
            addPlatform(0, 500, 400, 50);

            // First combat zone
            addPlatform(450, 500, 200, 50);
            enemies.push(new Enemy(500, 450, 'soldier'));
            enemies.push(new Enemy(550, 450, 'soldier'));

            // Jump to next zone
            addPlatform(700, 450, 150, 50);
            addPlatform(900, 400, 150, 50);

            // Second combat zone
            addPlatform(1100, 500, 300, 50);
            enemies.push(new Enemy(1150, 450, 'soldier'));
            enemies.push(new Enemy(1250, 450, 'soldier'));
            enemies.push(new Enemy(1200, 450, 'soldier'));

            // Health pickup after combat
            interactables.push(new Interactable(1200, 430, 24, 24, 'health'));

            // Vertical section with enemies
            addPlatform(1450, 500, 100, 50);
            addPlatform(1400, 400, 80, 20);
            addPlatform(1350, 300, 80, 20);
            enemies.push(new Enemy(1400, 350, 'soldier'));

            // Crystal power-up for double jump advantage
            interactables.push(new Interactable(1350, 250, 24, 40, 'crystal'));

            // Third combat zone - boss area
            addPlatform(1600, 500, 400, 50);
            enemies.push(new Enemy(1700, 450, 'soldier'));
            enemies.push(new Enemy(1800, 450, 'soldier'));
            enemies.push(new Enemy(1750, 450, 'soldier'));
            enemies.push(new Enemy(1850, 450, 'soldier'));

            // More health pickups
            interactables.push(new Interactable(1750, 430, 24, 24, 'health'));
            interactables.push(new Interactable(1850, 430, 24, 24, 'health'));

            // Final sprint with obstacles
            addPlatform(2050, 500, 150, 50);
            addHazard(2100, 480, 50, 20, 'spikes');

            addPlatform(2250, 500, 150, 50);
            addHazard(2300, 480, 50, 20, 'spikes');

            // Final stretch
            addPlatform(2450, 500, 50, 50);

            // Checkpoint for player
            interactables.push(new Interactable(1200, 450, 24, 50, 'checkpoint'));

            // Combat race UIÊèêÁ§∫
            updatePuzzleHint();
        }

        function createBossFight() {
            // Reset game objects for boss fight
            coins = [];
            powerups = [];
            finishFlag = null;

            // EPIC FINAL BOSS ARENA
            levelWidth = 1600;
            levelHeight = 800;

            // Enhanced player for final battle
            player = new Player(100, 600);
            player.health = 200;
            player.maxHealth = 200;
            player.jumpForce = -800; // Increased jump intensity for Episode 4
            currentCheckpoint = { x: 100, y: 600 };

            // ARENA DESIGN - Throne Room of Fire
            // Main floor
            addPlatform(0, 700, 1600, 100);

            // Elevated platforms for strategic combat
            addPlatform(200, 550, 120, 20);
            addPlatform(400, 480, 100, 20);
            addPlatform(600, 420, 80, 20);
            addPlatform(800, 480, 100, 20);
            addPlatform(1000, 550, 120, 20);
            addPlatform(1280, 500, 150, 20);

            // Side platforms
            addPlatform(0, 400, 80, 300);
            addPlatform(1520, 400, 80, 300);

            // Floating platforms for aerial combat
            addPlatform(300, 350, 60, 15);
            addPlatform(500, 300, 60, 15);
            addPlatform(700, 250, 80, 15);
            addPlatform(900, 300, 60, 15);
            addPlatform(1100, 350, 60, 15);

            // Lava pits (hazards)
            addHazard(250, 680, 100, 20, 'lava');
            addHazard(650, 680, 120, 20, 'lava');
            addHazard(1050, 680, 100, 20, 'lava');

            // Strategic health pickups
            interactables.push(new Interactable(230, 500, 24, 24, 'health'));
            interactables.push(new Interactable(530, 430, 24, 24, 'health'));
            interactables.push(new Interactable(830, 430, 24, 24, 'health'));
            interactables.push(new Interactable(1130, 500, 24, 24, 'health'));
            interactables.push(new Interactable(1330, 450, 24, 24, 'health'));

            // Powerups for epic battle
            powerups.push(new Powerup(350, 300, 'health'));
            powerups.push(new Powerup(550, 250, 'speed'));
            powerups.push(new Powerup(750, 200, 'jump'));
            powerups.push(new Powerup(950, 250, 'magnet'));
            powerups.push(new Powerup(1150, 300, 'health'));

            // Coins scattered around arena
            for (let i = 0; i < 8; i++) {
                coins.push(new Coin(200 + i * 150, 650));
            }
            for (let i = 0; i < 6; i++) {
                coins.push(new Coin(300 + i * 120, 450));
            }

            // EPIC FINAL BOSS - GENERAL RAVANA, THE FIRE ANT KING
            const boss = new Enemy(1200, 200, 'boss');
            boss.health = 2000; // Massive health pool
            boss.maxHealth = 2000;
            boss.x = 1200;
            boss.y = 200;
            boss.vx = 0;
            boss.vy = 0;
            boss.fixed = false; // This boss MOVES!
            boss.attackTimer = 0;
            boss.specialAttackTimer = 0;
            boss.bossPhase = 1;
            boss.moveSpeed = 100;
            boss.moveTimer = 0;
            boss.moveDirection = 1;
            boss.enraged = false;
            boss.shieldActive = false;
            boss.summonTimer = 0;
            enemies.push(boss);

            // Boss UI
            document.getElementById('bossHealth').style.display = 'block';
            document.getElementById('bossHealth').className = 'phase1';
            document.getElementById('bossHealthFill').style.width = '100%';

            // Update player health display
            document.getElementById('healthFill').style.width = '100%';
        }

        function spawnBossAttackIndicators() {
            // Visual warnings for boss attacks
            const warningIndicator = {
                x: 0, y: 0, width: 50, height: 50,
                type: 'warning',
                timer: 0,
                pattern: null
            };
            // Will be used in boss AI for attack telegraphs
        }

        function addPlatform(x, y, w, h) {
            platforms.push({ x, y, width: w, height: h, type: 'solid' });
        }

        function addHazard(x, y, w, h, type) {
            hazards.push({ x, y, width: w, height: h, type, damage: 20 });
        }

        function updatePuzzleUI() {
            if (currentLevel === 2) {
                document.getElementById('puzzleHint').textContent =
                    `Puzzles Solved: ${puzzlesSolved} / ${puzzlesRequired}`;
                updatePuzzleHint();
            }
        }

        function updatePuzzleHint() {
            if (currentLevel === 2) {
                const hints = [
                    "Find the crystal sequence: Red ‚Üí Blue ‚Üí Green",
                    "Activate all pressure plates to proceed",
                    "Use the timed lever quickly before the door closes!"
                ];
                const currentHint = hints[Math.min(puzzlesSolved, hints.length - 1)];
                document.getElementById('puzzleHint').textContent = currentHint;
            }
        }

        // ==================== DRAWING ====================
        // ==================== REALISTIC DIRT BACKGROUND SYSTEM ====================
        // Per-level color palettes for the underground
        const levelPalettes = {
            1: { // Episode I - Deep dark soil tunnels
                bg1: '#0d0806', bg2: '#1a0f0a', bg3: '#2a1c12', bg4: '#3a2818',
                soil1: '#3a2818', soil2: '#4a3420', soil3: '#5a4230',
                dirt1: '#2a1810', dirt2: '#3a2618', dirt3: '#4a3628',
                rock1: '#4a4a5a', rock2: '#5a5a6a', rock3: '#6a6a7a',
                clay: '#6a3a2a', root: '#3a2a1a', moss: '#2a3a22',
                crystal: '#44aaaa', moisture: 'rgba(60,80,100,0.15)',
                accent: '#ffd700'
            },
            2: { // Episode II - Ancient clay/amber puzzle chambers  
                bg1: '#0f0a06', bg2: '#1e150c', bg3: '#2e2216', bg4: '#3e3020',
                soil1: '#4a3420', soil2: '#5a4230', soil3: '#6a5240',
                dirt1: '#3a2618', dirt2: '#4a3828', dirt3: '#5a4838',
                rock1: '#5a4a3a', rock2: '#6a5a4a', rock3: '#7a6a5a',
                clay: '#8a5a3a', root: '#4a3a2a', moss: '#3a4a2a',
                crystal: '#ffaa44', moisture: 'rgba(80,60,40,0.12)',
                accent: '#ff8c00'
            },
            3: { // Episode III - Wet underground caverns (race)
                bg1: '#060a0d', bg2: '#0c151e', bg3: '#15222e', bg4: '#1e303e',
                soil1: '#2a3040', soil2: '#3a4050', soil3: '#4a5060',
                dirt1: '#1a2030', dirt2: '#2a3040', dirt3: '#3a4050',
                rock1: '#4a5a6a', rock2: '#5a6a7a', rock3: '#6a7a8a',
                clay: '#4a5a6a', root: '#2a3a2a', moss: '#2a4a3a',
                crystal: '#44ddff', moisture: 'rgba(40,80,120,0.2)',
                accent: '#00ccff'
            },
            4: { // Episode IV - Volcanic boss arena
                bg1: '#0d0504', bg2: '#1e0a06', bg3: '#2e140a', bg4: '#3e1a0e',
                soil1: '#3a1a10', soil2: '#4a2218', soil3: '#5a2a20',
                dirt1: '#2a1008', dirt2: '#3a1810', dirt3: '#4a2218',
                rock1: '#3a3a3a', rock2: '#4a4a4a', rock3: '#5a5a5a',
                clay: '#6a2a1a', root: '#2a1a0a', moss: '#3a2a1a',
                crystal: '#ff4400', moisture: 'rgba(120,40,20,0.15)',
                accent: '#ff4500'
            }
        };

        // Seeded random for consistent textures
        function seededRandom(seed) {
            let s = seed;
            return function () {
                s = (s * 16807 + 0) % 2147483647;
                return (s - 1) / 2147483646;
            };
        }

        // Cache background textures per level
        const bgTextureCache = {};

        function generateDirtTexture(level, width, height) {
            const key = `${level}_${width}_${height}`;
            if (bgTextureCache[key]) return bgTextureCache[key];

            const offscreen = document.createElement('canvas');
            offscreen.width = width;
            offscreen.height = height;
            const octx = offscreen.getContext('2d');
            const pal = levelPalettes[level] || levelPalettes[1];
            const rng = seededRandom(level * 7919);

            // 1. Base gradient fill ‚Äî deep underground gradient
            const baseGrad = octx.createLinearGradient(0, 0, 0, height);
            baseGrad.addColorStop(0, pal.bg1);
            baseGrad.addColorStop(0.25, pal.bg2);
            baseGrad.addColorStop(0.6, pal.bg3);
            baseGrad.addColorStop(1, pal.bg4);
            octx.fillStyle = baseGrad;
            octx.fillRect(0, 0, width, height);

            // 2. Soil strata layers ‚Äî horizontal wavy bands
            for (let layer = 0; layer < 6; layer++) {
                const layerY = (height * 0.15) + layer * (height * 0.14);
                const thickness = 8 + rng() * 25;
                const soilColors = [pal.soil1, pal.soil2, pal.soil3, pal.dirt1, pal.dirt2, pal.dirt3];
                octx.fillStyle = soilColors[layer % soilColors.length];
                octx.globalAlpha = 0.3 + rng() * 0.3;
                octx.beginPath();
                octx.moveTo(0, layerY);
                for (let x = 0; x <= width; x += 20) {
                    const waveY = layerY + Math.sin(x * 0.008 + layer * 2.1) * 15
                        + Math.sin(x * 0.02 + layer * 0.7) * 8;
                    octx.lineTo(x, waveY);
                }
                for (let x = width; x >= 0; x -= 20) {
                    const waveY = layerY + thickness + Math.sin(x * 0.008 + layer * 2.1) * 10
                        + Math.sin(x * 0.015 + layer) * 6;
                    octx.lineTo(x, waveY);
                }
                octx.closePath();
                octx.fill();
                octx.globalAlpha = 1;
            }

            // 3. Dirt particle noise ‚Äî tiny specks for realistic texture
            for (let i = 0; i < 3000; i++) {
                const px = rng() * width;
                const py = rng() * height;
                const size = 0.5 + rng() * 2;
                const brightness = 20 + Math.floor(rng() * 40);
                octx.fillStyle = `rgba(${brightness + 30}, ${brightness + 15}, ${brightness}, ${0.15 + rng() * 0.25})`;
                octx.fillRect(px, py, size, size);
            }

            // 4. Embedded rocks & pebbles
            for (let i = 0; i < 40; i++) {
                const rx = rng() * width;
                const ry = rng() * height;
                const rw = 4 + rng() * 18;
                const rh = 3 + rng() * 12;
                const rockColor = [pal.rock1, pal.rock2, pal.rock3][Math.floor(rng() * 3)];

                octx.globalAlpha = 0.4 + rng() * 0.4;
                octx.fillStyle = rockColor;
                octx.beginPath();
                octx.ellipse(rx, ry, rw, rh, rng() * Math.PI, 0, Math.PI * 2);
                octx.fill();

                // Rock highlight
                octx.fillStyle = 'rgba(255,255,255,0.08)';
                octx.beginPath();
                octx.ellipse(rx - rw * 0.2, ry - rh * 0.3, rw * 0.5, rh * 0.4, rng() * Math.PI, 0, Math.PI * 2);
                octx.fill();
                octx.globalAlpha = 1;
            }

            // 5. Clay deposits ‚Äî larger organic patches
            for (let i = 0; i < 12; i++) {
                const cx = rng() * width;
                const cy = rng() * height;
                octx.globalAlpha = 0.2 + rng() * 0.15;
                octx.fillStyle = pal.clay;
                octx.beginPath();
                octx.ellipse(cx, cy, 15 + rng() * 30, 8 + rng() * 15, rng() * Math.PI, 0, Math.PI * 2);
                octx.fill();
                octx.globalAlpha = 1;
            }

            // 6. Root systems ‚Äî organic branching lines across the dirt
            for (let r = 0; r < 10; r++) {
                let rx = rng() * width;
                let ry = rng() * height * 0.4;
                octx.strokeStyle = pal.root;
                octx.lineWidth = 1 + rng() * 3;
                octx.globalAlpha = 0.3 + rng() * 0.4;
                octx.beginPath();
                octx.moveTo(rx, ry);
                const segments = 5 + Math.floor(rng() * 8);
                for (let s = 0; s < segments; s++) {
                    rx += (rng() - 0.3) * 40;
                    ry += 15 + rng() * 30;
                    octx.lineTo(rx, ry);
                    // Branch off
                    if (rng() > 0.5) {
                        const bx = rx + (rng() - 0.5) * 50;
                        const by = ry + 10 + rng() * 20;
                        octx.moveTo(rx, ry);
                        octx.lineTo(bx, by);
                        octx.moveTo(rx, ry);
                    }
                }
                octx.stroke();
                octx.globalAlpha = 1;
            }

            // 7. Moisture / water seepage patches
            for (let i = 0; i < 8; i++) {
                const mx = rng() * width;
                const my = rng() * height;
                const mr = 20 + rng() * 60;
                const grad = octx.createRadialGradient(mx, my, 0, mx, my, mr);
                grad.addColorStop(0, pal.moisture);
                grad.addColorStop(1, 'transparent');
                octx.fillStyle = grad;
                octx.fillRect(mx - mr, my - mr, mr * 2, mr * 2);
            }

            // 8. Small crystal/mineral deposits ‚Äî glowing specks
            for (let i = 0; i < 15; i++) {
                const cx = rng() * width;
                const cy = rng() * height;
                const cs = 1 + rng() * 3;
                octx.fillStyle = pal.crystal;
                octx.globalAlpha = 0.3 + rng() * 0.5;
                octx.shadowColor = pal.crystal;
                octx.shadowBlur = 6;
                octx.beginPath();
                octx.arc(cx, cy, cs, 0, Math.PI * 2);
                octx.fill();
                octx.shadowBlur = 0;
                octx.globalAlpha = 1;
            }

            // 9. Worm/insect tunnels ‚Äî thin dark curved lines
            for (let i = 0; i < 5; i++) {
                let tx = rng() * width;
                let ty = height * 0.3 + rng() * height * 0.5;
                octx.strokeStyle = 'rgba(0,0,0,0.15)';
                octx.lineWidth = 2 + rng() * 2;
                octx.beginPath();
                octx.moveTo(tx, ty);
                for (let s = 0; s < 6; s++) {
                    tx += 20 + rng() * 40;
                    ty += (rng() - 0.5) * 30;
                    octx.lineTo(tx, ty);
                }
                octx.stroke();
            }

            // 10. Moss patches along ceiling area
            for (let i = 0; i < 20; i++) {
                const mx = rng() * width;
                const my = rng() * height * 0.15;
                octx.fillStyle = pal.moss;
                octx.globalAlpha = 0.2 + rng() * 0.2;
                octx.beginPath();
                octx.ellipse(mx, my, 8 + rng() * 20, 3 + rng() * 8, 0, 0, Math.PI * 2);
                octx.fill();
                octx.globalAlpha = 1;
            }

            // 11. Vignette for depth
            const vigGrad = octx.createRadialGradient(
                width / 2, height / 2, height * 0.3,
                width / 2, height / 2, height * 0.9
            );
            vigGrad.addColorStop(0, 'transparent');
            vigGrad.addColorStop(1, 'rgba(0,0,0,0.35)');
            octx.fillStyle = vigGrad;
            octx.fillRect(0, 0, width, height);

            bgTextureCache[key] = offscreen;
            return offscreen;
        }

        // Main background draw function ‚Äî uses cached textures with parallax
        function drawBackground(ctx) {
            const lvl = currentLevel || 1;
            const pal = levelPalettes[lvl] || levelPalettes[1];

            // Generate/get cached dirt textures at different scales for parallax layers
            const texW = canvas.width * 2;
            const texH = canvas.height;
            const tex = generateDirtTexture(lvl, texW, texH);

            // Draw the background texture with parallax ‚Äî far layer (slow)
            const farOffset = (-camera.x * 0.15) % texW;
            ctx.drawImage(tex, farOffset, 0, texW, texH, 0, 0, canvas.width, canvas.height);
            // Tile seam fill
            if (farOffset < 0) {
                ctx.drawImage(tex, farOffset + texW, 0, texW, texH, 0, 0, canvas.width, canvas.height);
            }

            // Mid parallax layer ‚Äî overlay with slight offset for depth
            ctx.globalAlpha = 0.3;
            const midOffset = (-camera.x * 0.35) % texW;
            ctx.drawImage(tex, midOffset + texW * 0.3, texH * 0.1, texW * 0.7, texH * 0.8,
                0, canvas.height * 0.1, canvas.width, canvas.height * 0.8);
            ctx.globalAlpha = 1;

            // Animated ambient effects drawn live (not cached)
            drawAmbientEffects(ctx, lvl, pal);
        }

        // Live ambient effects ‚Äî these animate and shouldn't be cached
        function drawAmbientEffects(ctx, level, pal) {
            const time = gameTime;

            // Floating dust particles
            for (let i = 0; i < 12; i++) {
                const px = ((i * 137 + time * 8 * (i % 3 + 1)) % (canvas.width + 40)) - 20;
                const py = ((i * 89 + Math.sin(time * 0.5 + i) * 40 + time * 3) % (canvas.height + 20)) - 10;
                const size = 0.8 + Math.sin(time + i * 0.7) * 0.4;
                ctx.fillStyle = `rgba(180,160,140,${0.15 + Math.sin(time * 0.8 + i) * 0.1})`;
                ctx.beginPath();
                ctx.arc(px, py, size, 0, Math.PI * 2);
                ctx.fill();
            }

            // Dripping water effect (for level 3 ‚Äî wet caverns)
            if (level === 3) {
                for (let i = 0; i < 5; i++) {
                    const dx = (i * 280 - camera.x * 0.2) % (canvas.width + 200);
                    const dripPhase = (time * 2 + i * 1.7) % 3;
                    if (dripPhase < 1.5) {
                        const dy = dripPhase / 1.5 * canvas.height * 0.5;
                        ctx.fillStyle = `rgba(100,180,220,${0.5 - dripPhase * 0.3})`;
                        ctx.beginPath();
                        ctx.ellipse(dx, dy, 1.5, 3 + dripPhase * 2, 0, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Ember/lava glow particles (for level 4 ‚Äî volcanic)
            if (level === 4) {
                for (let i = 0; i < 10; i++) {
                    const ex = ((i * 173 + time * 15) % (canvas.width + 40)) - 20;
                    const ey = canvas.height - ((i * 97 + time * 30 + Math.sin(time + i) * 20) % (canvas.height * 0.6));
                    const eSize = 1 + Math.sin(time * 2 + i) * 0.5;
                    ctx.fillStyle = `rgba(255,${80 + Math.floor(Math.sin(time + i) * 40)},0,${0.3 + Math.sin(time * 1.5 + i) * 0.2})`;
                    ctx.shadowColor = '#ff4500';
                    ctx.shadowBlur = 4;
                    ctx.beginPath();
                    ctx.arc(ex, ey, eSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }

            // Ambient crystal shimmer (for level 2 ‚Äî puzzle chamber)
            if (level === 2) {
                for (let i = 0; i < 6; i++) {
                    const sx = (i * 230 - camera.x * 0.1) % (canvas.width + 200);
                    const sy = 40 + i * 80 + Math.sin(time * 0.3 + i) * 15;
                    const shimmer = Math.sin(time * 2 + i * 1.2) * 0.5 + 0.5;
                    ctx.fillStyle = `rgba(255,170,68,${shimmer * 0.2})`;
                    ctx.shadowColor = '#ffaa44';
                    ctx.shadowBlur = 8 * shimmer;
                    ctx.beginPath();
                    ctx.arc(sx, sy, 2 + shimmer * 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }

            // Subtle ceiling stalactite shadows (all levels)
            ctx.fillStyle = 'rgba(0,0,0,0.15)';
            for (let i = 0; i < 8; i++) {
                const stX = (i * 190 - camera.x * 0.25) % (canvas.width + 200) - 20;
                const stH = 30 + Math.sin(i * 2.3) * 20;
                ctx.beginPath();
                ctx.moveTo(stX - 8, 0);
                ctx.lineTo(stX, stH);
                ctx.lineTo(stX + 8, 0);
                ctx.closePath();
                ctx.fill();
            }

            // Floor gradient ‚Äî darker soil at bottom
            const floorGrad = ctx.createLinearGradient(0, canvas.height - 80, 0, canvas.height);
            floorGrad.addColorStop(0, 'transparent');
            floorGrad.addColorStop(1, 'rgba(0,0,0,0.4)');
            ctx.fillStyle = floorGrad;
            ctx.fillRect(0, canvas.height - 80, canvas.width, 80);
        }

        function drawPlatforms(ctx, cam) {
            for (const p of platforms) {
                const screenX = p.x - cam.x;
                const screenY = p.y - cam.y;

                // Main platform with dirt/soil texture
                const gradient = ctx.createLinearGradient(screenX, screenY, screenX, screenY + p.height);
                gradient.addColorStop(0, Colors.dirtLight);
                gradient.addColorStop(0.3, Colors.dirt);
                gradient.addColorStop(0.7, Colors.soil);
                gradient.addColorStop(1, Colors.soilDark);
                ctx.fillStyle = gradient;
                ctx.fillRect(screenX, screenY, p.width, p.height);

                // Stone/rock overlay on top
                ctx.fillStyle = Colors.stone;
                ctx.fillRect(screenX, screenY, p.width, 6);

                // Soil texture patches
                ctx.fillStyle = Colors.soilLight;
                for (let i = 0; i < p.width; i += 25) {
                    if (Math.random() > 0.3) {
                        ctx.fillRect(screenX + i + 8, screenY + 10, 12, 4);
                    }
                }

                // Clay deposits
                ctx.fillStyle = Colors.clay;
                for (let i = 0; i < p.width; i += 40) {
                    if (Math.random() > 0.5) {
                        ctx.fillRect(screenX + i + 15, screenY + 15, 8, 8);
                    }
                }

                // Stone pebbles
                ctx.fillStyle = Colors.stoneDark;
                for (let i = 0; i < p.width; i += 30) {
                    ctx.beginPath();
                    ctx.arc(screenX + i + 10, screenY + p.height - 8, 3, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Bottom shadow
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.fillRect(screenX, screenY + p.height - 6, p.width, 6);

                // Moss patches on edges
                if (Math.random() > 0.6) {
                    ctx.fillStyle = Colors.moss;
                    ctx.fillRect(screenX, screenY, p.width, 2);
                }
            }
        }

        function drawHazards(ctx, cam) {
            for (const h of hazards) {
                const screenX = h.x - cam.x;
                const screenY = h.y - cam.y;

                if (h.type === 'spikes') {
                    ctx.fillStyle = Colors.spike;
                    const spikeWidth = 15;
                    const spikeCount = Math.floor(h.width / spikeWidth);

                    for (let i = 0; i < spikeCount; i++) {
                        ctx.beginPath();
                        ctx.moveTo(screenX + i * spikeWidth, screenY + h.height);
                        ctx.lineTo(screenX + i * spikeWidth + spikeWidth / 2, screenY);
                        ctx.lineTo(screenX + (i + 1) * spikeWidth, screenY + h.height);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Glow effect
                    ctx.fillStyle = 'rgba(139, 0, 0, 0.3)';
                    ctx.fillRect(screenX - 5, screenY - 5, h.width + 10, h.height + 10);
                } else if (h.type === 'lava') {
                    // Animated lava
                    ctx.fillStyle = Colors.lava;
                    ctx.fillRect(screenX, screenY, h.width, h.height);

                    // Bubbles
                    ctx.fillStyle = Colors.lavaGlow;
                    for (let i = 0; i < 5; i++) {
                        const bx = screenX + (Math.sin(gameTime * 2 + i) * 0.5 + 0.5) * h.width;
                        const by = screenY + Math.abs(Math.sin(gameTime * 3 + i * 2)) * h.height * 0.5;
                        ctx.beginPath();
                        ctx.arc(bx, by, 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        function drawGoal(ctx, cam) {
            if (!levelGoal) return;

            const screenX = levelGoal.x - cam.x;
            const screenY = levelGoal.y - cam.y;

            // Glowing portal effect
            ctx.fillStyle = `rgba(255, 215, 0, ${0.3 + Math.sin(gameTime * 3) * 0.1})`;
            ctx.beginPath();
            ctx.ellipse(screenX + levelGoal.width / 2, screenY + levelGoal.height / 2,
                levelGoal.width, levelGoal.height / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Inner glow
            ctx.fillStyle = `rgba(255, 255, 200, ${0.5 + Math.sin(gameTime * 4) * 0.2})`;
            ctx.beginPath();
            ctx.ellipse(screenX + levelGoal.width / 2, screenY + levelGoal.height / 2,
                levelGoal.width * 0.6, levelGoal.height * 0.3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Particles
            if (Math.random() < 0.2) {
                spawnParticles(
                    levelGoal.x + Math.random() * levelGoal.width,
                    levelGoal.y + levelGoal.height,
                    1, Colors.gold, 30, 2, 1, -50
                );
            }
        }

        function drawTorchLight(ctx, x, y, radius) {
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
            gradient.addColorStop(0, 'rgba(255, 150, 50, 0.4)');
            gradient.addColorStop(0.5, 'rgba(255, 100, 30, 0.2)');
            gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawAmbientLighting(ctx, cam) {
            // Bioluminescent fungi lights
            const fungiSpacing = 350;
            const startX = Math.floor(cam.x / fungiSpacing) * fungiSpacing;

            for (let x = startX; x < cam.x + canvas.width + fungiSpacing; x += fungiSpacing) {
                const screenX = x - cam.x;
                const flicker = Math.sin(gameTime * 8 + x * 0.01) * 15;
                // Greenish bioluminescent light
                const gradient = ctx.createRadialGradient(screenX, canvas.height - 150, 0, screenX, canvas.height - 150, 100 + flicker);
                gradient.addColorStop(0, 'rgba(150, 255, 150, 0.3)');
                gradient.addColorStop(0.5, 'rgba(100, 200, 100, 0.15)');
                gradient.addColorStop(1, 'rgba(50, 150, 50, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(screenX, canvas.height - 150, 100 + flicker, 0, Math.PI * 2);
                ctx.fill();
            }

            // Crystal lights
            const crystalSpacing = 500;
            const crystalStartX = Math.floor(cam.x / crystalSpacing) * crystalSpacing;

            for (let x = crystalStartX; x < cam.x + canvas.width + crystalSpacing; x += crystalSpacing) {
                const screenX = x - cam.x;
                const flicker = Math.sin(gameTime * 12 + x * 0.02) * 20;
                // Blue crystal light
                const gradient = ctx.createRadialGradient(screenX, 200, 0, screenX, 200, 80 + flicker);
                gradient.addColorStop(0, 'rgba(0, 255, 255, 0.4)');
                gradient.addColorStop(0.5, 'rgba(0, 200, 255, 0.2)');
                gradient.addColorStop(1, 'rgba(0, 150, 255, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(screenX, 200, 80 + flicker, 0, Math.PI * 2);
                ctx.fill();
            }

            // Player light (warmer tone)
            const playerScreenX = player.x - cam.x + player.width / 2;
            const playerScreenY = player.y - cam.y + player.height / 2;
            const gradient = ctx.createRadialGradient(playerScreenX, playerScreenY, 0, playerScreenX, playerScreenY, 120);
            gradient.addColorStop(0, 'rgba(255, 200, 150, 0.6)');
            gradient.addColorStop(0.5, 'rgba(255, 150, 100, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 100, 50, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(playerScreenX, playerScreenY, 120, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawRacePosition(ctx) {
            if (currentLevel !== 3) return;

            // Calculate positions
            let positions = [
                { name: 'You', x: player.x, isPlayer: true },
                ...racers.map((r, i) => ({ name: `Enemy ${i + 1}`, x: r.x, isPlayer: false }))
            ];

            positions.sort((a, b) => b.x - a.x);
            const playerPos = positions.findIndex(p => p.isPlayer) + 1;

            const posText = playerPos === 1 ? '1st' : playerPos === 2 ? '2nd' :
                playerPos === 3 ? '3rd' : `${playerPos}th`;

            document.getElementById('racePosition').textContent = posText;
            document.getElementById('racePosition').style.color =
                playerPos === 1 ? Colors.gold : playerPos <= 2 ? '#00ff00' : '#ff4444';
        }

        // ==================== GAME LOOP ====================
        function update(dt) {
            gameTime += dt;

            if (currentState !== GameState.PLAYING) return;

            // Update player
            player.update(dt, platforms, hazards, enemies);

            // Camera follow
            camera.follow(player, levelWidth, levelHeight);

            // Update enemies
            enemies.forEach(e => e.update(dt, player, platforms));

            // Update racers (level 3)
            if (currentLevel === 3) {
                raceTimer += dt;
                racers.forEach(r => {
                    if (!r.finished) {
                        r.update(dt, platforms, hazards);
                        // Check if this racer finished
                        if (levelGoal && r.x >= levelGoal.x) {
                            r.finished = true;
                        }
                    }
                });

                // Only check for race loss if player hasn't finished
                if (levelGoal && player.x < levelGoal.x) {
                    const allRacersFinished = racers.every(r => r.finished);
                    if (allRacersFinished) {
                        // Immediate game over - no setTimeout to prevent freezing
                        gameOver();
                    }
                }
            }

            // Update interactables
            interactables.forEach(i => i.update(dt, player));

            // Update coins
            coins.forEach(coin => {
                coin.update(dt);
                if (!coin.collected && player.collides(coin)) {
                    coin.collect();
                }
            });

            // Update powerups
            powerups.forEach(powerup => {
                powerup.update(dt);
                if (!powerup.collected && player.collides(powerup)) {
                    powerup.collect();
                }
            });

            // Update finish flag
            if (finishFlag) {
                finishFlag.update(dt);
                finishFlag.checkReach(player);
            }

            // Check goal
            if (levelGoal) {
                if (player.x < levelGoal.x + levelGoal.width &&
                    player.x + player.width > levelGoal.x &&
                    player.y < levelGoal.y + levelGoal.height &&
                    player.y + player.height > levelGoal.y) {

                    // Level 2 requires puzzles
                    if (currentLevel === 2 && puzzlesSolved < puzzlesRequired) {
                        // Can't exit yet - show feedback
                        spawnParticles(player.x + player.width / 2, player.y, 10, Colors.spike, 80, 3, 0.5, 100);
                    } else {
                        levelComplete();
                    }
                }
            }

            // Check death by falling
            if (player.y > levelHeight + 100) {
                if (currentCheckpoint) {
                    player.x = currentCheckpoint.x;
                    player.y = currentCheckpoint.y;
                    player.vy = 0;
                    player.takeDamage(20);
                } else {
                    gameOver();
                }
            }

            // Update particles
            updateParticles(dt);

            // Update boss spears
            for (const enemy of enemies) {
                if (enemy.spears) {
                    for (let i = enemy.spears.length - 1; i >= 0; i--) {
                        const spear = enemy.spears[i];
                        spear.x += spear.vx * dt;
                        spear.y += spear.vy * dt;
                        spear.vy += 300 * dt; // Gravity
                        spear.lifetime -= dt;

                        // Check collision with player
                        if (player.collidesWith(spear)) {
                            player.takeDamage(spear.damage);
                            enemy.spears.splice(i, 1);
                            spawnParticles(spear.x, spear.y, 10, Colors.stone, 80, 3, 0.5, 0);
                            continue;
                        }

                        // Check collision with platforms
                        for (const platform of platforms) {
                            if (spear.x < platform.x + platform.width &&
                                spear.x + spear.width > platform.x &&
                                spear.y < platform.y + platform.height &&
                                spear.y + spear.height > platform.y) {
                                enemy.spears.splice(i, 1);
                                spawnParticles(spear.x, spear.y, 8, Colors.stone, 60, 2, 0.5, 0);
                                break;
                            }
                        }

                        // Remove if lifetime expired
                        if (spear.lifetime <= 0) {
                            enemy.spears.splice(i, 1);
                        }
                    }
                }
            }

            // Update player bullets
            if (player.bullets) {
                for (let i = player.bullets.length - 1; i >= 0; i--) {
                    const bullet = player.bullets[i];
                    bullet.x += bullet.vx * dt;
                    bullet.y += bullet.vy * dt;
                    bullet.lifetime -= dt;

                    // Remove if lifetime expired first
                    if (bullet.lifetime <= 0) {
                        player.bullets.splice(i, 1);
                        continue;
                    }

                    // Check collision with enemies
                    let bulletRemoved = false;
                    for (const enemy of enemies) {
                        if (!enemy.dead && enemy.collides(bullet)) {
                            enemy.takeDamage(bullet.damage);
                            player.bullets.splice(i, 1);
                            spawnParticles(bullet.x, bullet.y, 8, '#00ffff', 60, 2, 0.5, 0);
                            bulletRemoved = true;
                            break;
                        }
                    }
                    if (bulletRemoved) continue;

                    // Check collision with platforms
                    for (const platform of platforms) {
                        if (bullet.x < platform.x + platform.width &&
                            bullet.x + bullet.width > platform.x &&
                            bullet.y < platform.y + platform.height &&
                            bullet.y + bullet.height > platform.y) {
                            player.bullets.splice(i, 1);
                            spawnParticles(bullet.x, bullet.y, 5, '#00ffff', 40, 2, 0.5, 0);
                            break;
                        }
                    }
                }
            }

            // Ambient particles
            if (Math.random() < 0.05) {
                spawnParticles(
                    camera.x + Math.random() * canvas.width,
                    camera.y + Math.random() * canvas.height,
                    1, 'rgba(100, 100, 150, 0.5)', 10, 2, 3, 5
                );
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Background
            drawBackground(ctx);

            if (currentState === GameState.PLAYING || currentState === GameState.PAUSED) {
                // Ambient lighting first (under everything)
                drawAmbientLighting(ctx, camera);

                // Level elements
                drawPlatforms(ctx, camera);
                drawHazards(ctx, camera);

                // Interactables
                interactables.forEach(i => i.draw(ctx, camera));

                // Coins
                coins.forEach(coin => coin.draw(ctx, camera));

                // Powerups
                powerups.forEach(powerup => powerup.draw(ctx, camera));

                // Finish flag
                if (finishFlag) {
                    finishFlag.draw(ctx, camera);
                }

                // Goal
                drawGoal(ctx, camera);

                // Racers
                racers.forEach(r => r.draw(ctx, camera));

                // Enemies
                enemies.forEach(e => e.draw(ctx, camera));

                // Draw boss spears
                for (const enemy of enemies) {
                    if (enemy.spears) {
                        for (const spear of enemy.spears) {
                            const screenX = spear.x - camera.x;
                            const screenY = spear.y - camera.y;

                            // Spear projectile
                            ctx.fillStyle = Colors.stone;
                            ctx.fillRect(screenX, screenY, spear.width, spear.height);

                            // Spear tip
                            ctx.fillStyle = '#2a2a2a';
                            ctx.fillRect(screenX + spear.width - 4, screenY - 2, 4, 2);
                        }
                    }
                }

                // Draw player bullets
                if (player.bullets) {
                    for (const bullet of player.bullets) {
                        const screenX = bullet.x - camera.x;
                        const screenY = bullet.y - camera.y;

                        ctx.save();
                        // Move context to bullet center to allow rotation
                        ctx.translate(screenX + bullet.width / 2, screenY + bullet.height / 2);

                        // Calculate angle based on velocity
                        const angle = Math.atan2(bullet.vy, bullet.vx);
                        ctx.rotate(angle);

                        // Player bullet with glow effect
                        ctx.shadowColor = '#00ffff';
                        ctx.shadowBlur = 8;
                        ctx.fillStyle = '#00ffff';

                        // Draw bullet centered at 0,0 since we translated
                        // Using fixed dimensions for the visual representation regardless of hitbox
                        const visWidth = 14;
                        const visHeight = 6;
                        ctx.fillRect(-visWidth / 2, -visHeight / 2, visWidth, visHeight);
                        ctx.shadowBlur = 0;

                        // Bullet trail extending backwards (-X direction in local space)
                        ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                        ctx.fillRect(-visWidth / 2 - 12, -visHeight / 2 + 1, 12, visHeight - 2);

                        ctx.restore();
                    }
                }

                // Player
                player.draw(ctx, camera);

                // Particles (on top)
                drawParticles(ctx, camera);

                // Race UI
                drawRacePosition(ctx);

                // Vignette
                const vignette = ctx.createRadialGradient(
                    canvas.width / 2, canvas.height / 2, canvas.height * 0.3,
                    canvas.width / 2, canvas.height / 2, canvas.height
                );
                vignette.addColorStop(0, 'rgba(0,0,0,0)');
                vignette.addColorStop(1, 'rgba(0,0,0,0.6)');
                ctx.fillStyle = vignette;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        function gameLoop(timestamp) {
            deltaTime = Math.min((timestamp - lastTime) / 1000, 0.1);
            lastTime = timestamp;

            update(deltaTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        // ==================== CUTSCENES ====================
        const cutscenes = {
            intro: [
                { text: "Deep beneath the surface, in the underground kingdom of ANTHERA, a thriving ant civilization flourished...", speaker: null },
                { text: "Queen Sita, beloved matriarch of the colony, brought prosperity to all who dwelt within the underground tunnels.", speaker: null },
                { text: "But darkness invaded from the depths below...", speaker: null },
                { text: "The rival fire ant colony, led by the ruthless General Ravana, launched a surprise attack through secret tunnels.", speaker: null },
                { text: "They overwhelmed our defenses and captured the Queen, dragging her deep into the forbidden zones.", speaker: null },
                { text: "You are but a young worker ant, yet you alone witnessed their escape route through the ancient passages.", speaker: "NARRATOR" },
                { text: "The underground tunnels... where no light reaches... where ancient horrors dwell...", speaker: "NARRATOR" },
                { text: "Will you descend into darkness to save your Queen and colony?", speaker: "NARRATOR" }
            ],
            level1Intro: [
                { text: "EPISODE I: THE DESCENT", speaker: null, isTitle: true },
                { text: "The entrance to the lower tunnels looms before you, dark and foreboding.", speaker: null },
                { text: "You can hear the distant echoes of fire ant soldiers. They don't expect pursuit from a mere worker.", speaker: null },
                { text: "Navigate through the caverns. Watch for rockfalls and hostile patrols.", speaker: "ELDER ANT" },
                { text: "Your courage gives hope to the entire colony, young one.", speaker: "ELDER ANT" }
            ],
            level1Complete: [
                { text: "You've made it through the first layer of tunnels.", speaker: null },
                { text: "But the path ahead is blocked by the ancient Puzzle Chamber...", speaker: null },
                { text: "The old ones built these mechanisms to guard their most precious secrets.", speaker: null }
            ],
            level2Intro: [
                { text: "EPISODE II: THE PUZZLE CHAMBER", speaker: null, isTitle: true },
                { text: "Before you lies the legendary Puzzle Chamber of the Ancient Ants.", speaker: null },
                { text: "Many have entered. Few have emerged with their sanity intact.", speaker: null },
                { text: "The mechanisms respond to color sequences and pressure. Your ant instincts must guide you.", speaker: null },
                { text: "The fate of our Queen depends on your wit and courage, little one.", speaker: "ANCIENT SPIRIT" }
            ],
            level2Complete: [
                { text: "Incredible... you've solved the ancient puzzles that guard our realm.", speaker: null },
                { text: "But wait - fire ant reinforcements! They've found another way through!", speaker: null },
                { text: "You must outrun them to reach the Queen's location first!", speaker: null }
            ],
            level3Intro: [
                { text: "EPISODE III: THE RACE THROUGH DARKNESS", speaker: null, isTitle: true },
                { text: "Fire ant soldiers flood the tunnels behind you!", speaker: null },
                { text: "There's only one path forward - and they're taking it too.", speaker: null },
                { text: "Race through the underground passages. Use your agility to outmaneuver them!", speaker: null },
                { text: "The Queen's life depends on your speed, brave worker ant!", speaker: null }
            ],
            level3Complete: [
                { text: "You've outpaced them! The fire ant fortress lies ahead.", speaker: null },
                { text: "But one final challenge awaits...", speaker: null },
                { text: "General Ravana himself guards the Queen in his throne room.", speaker: null },
                { text: "Prepare yourself for the battle that will determine our colony's fate.", speaker: null }
            ],
            bossIntro: [
                { text: "FINAL EPISODE: THE THRONE ROOM CONFRONTATION", speaker: null, isTitle: true },
                { text: "So... a single worker ant dares to challenge me?", speaker: "GENERAL RAVANA" },
                { text: "I've crushed entire colonies beneath my feet. What chance do you have?", speaker: "GENERAL RAVANA" },
                { text: "Your Queen watches from her cage. Let her see your futile sacrifice!", speaker: "GENERAL RAVANA" },
                { text: "For Anthera! For Queen Sita! For the colony!", speaker: "YOU" }
            ]
        };

        let currentCutscene = null;
        let cutsceneIndex = 0;
        let cutsceneCallback = null;
        let typewriterText = '';
        let typewriterIndex = 0;
        let typewriterTimer = 0;
        let lastSpaceTime = 0;
        let spaceTapCount = 0;

        function playCutscene(name, callback) {
            currentCutscene = cutscenes[name];
            cutsceneIndex = 0;
            cutsceneCallback = callback;
            currentState = GameState.CUTSCENE;

            document.getElementById('cutsceneOverlay').style.display = 'flex';
            document.getElementById('hud').style.display = 'none';
            showCinematicBars(true);
            showCutsceneSlide();
        }

        function showCutsceneSlide() {
            if (cutsceneIndex >= currentCutscene.length) {
                endCutscene();
                return;
            }

            const slide = currentCutscene[cutsceneIndex];

            if (slide.isTitle) {
                document.getElementById('cutsceneText').innerHTML = slide.text;
            } else {
                // Normal text display (no typewriter)
                if (slide.speaker) {
                    document.getElementById('cutsceneText').innerHTML = `${slide.speaker}: ${slide.text}`;
                } else {
                    document.getElementById('cutsceneText').textContent = slide.text;
                }
            }
        }

        function advanceCutscene() {
            const currentTime = Date.now();

            // Check for double-tap (within 500ms)
            if (currentTime - lastSpaceTime < 500) {
                spaceTapCount++;
                if (spaceTapCount >= 2) {
                    // Double-tap detected, skip entire cutscene
                    endCutscene();
                    spaceTapCount = 0;
                    return;
                }
            } else {
                spaceTapCount = 1;
            }
            lastSpaceTime = currentTime;

            // Text is already fully displayed, just advance to next slide
            cutsceneIndex++;
            showCutsceneSlide();
        }

        function endCutscene() {
            // Hide cutscene overlay
            document.getElementById('cutsceneOverlay').style.display = 'none';
            showCinematicBars(false);

            // Reset cutscene state
            currentCutscene = null;
            cutsceneIndex = 0;

            // Execute callback if it exists
            if (cutsceneCallback) {
                const callback = cutsceneCallback;
                cutsceneCallback = null; // Clear callback to prevent multiple calls
                callback();
            }
        }

        function showCinematicBars(show) {
            const height = show ? '60px' : '0';
            document.getElementById('topBar').style.height = height;
            document.getElementById('bottomBar').style.height = height;
        }

        // ==================== GAME FLOW ====================
        function showTitleScreen() {
            currentState = GameState.MENU;
            document.getElementById('loading').style.display = 'none';
            document.getElementById('titleScreen').style.display = 'flex';
            document.getElementById('hud').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
            MusicEngine.play('menu');
        }

        function startGame() {
            document.getElementById('titleScreen').style.display = 'none';
            MusicEngine.play('cutscene');
            playCutscene('intro', () => startLevel(1));
        }

        function startLevel(level) {
            currentLevel = level;
            score = 0;
            coinsCollected = 0;
            updateHUD();

            // Create level FIRST
            createLevel(level);

            // Then set game state
            currentState = GameState.PLAYING;

            // Play appropriate music for the level
            if (level === 4) {
                MusicEngine.play('boss');
            } else {
                MusicEngine.play('level' + level);
            }

            // Reset UI
            document.getElementById('hud').style.display = 'flex';
            document.getElementById('controls').style.display = 'block';
            document.getElementById('levelComplete').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            if (level !== 4) {
                document.getElementById('bossHealth').style.display = 'none';
            }
            document.getElementById('puzzleUI').style.display = 'none';
            document.getElementById('racePosition').style.display = 'none';
            document.getElementById('timer').style.display = 'none';
            document.getElementById('healthFill').style.width = '100%';

            // Level-specific UI
            const levelNames = ['', 'The Descent', 'The Puzzle Chamber', 'The Race', 'The Confrontation'];
            document.getElementById('levelName').textContent = `EPISODE ${['', 'I', 'II', 'III', 'IV'][level]}`;
            document.getElementById('levelSubtitle').textContent = levelNames[level];

            if (level === 2) {
                document.getElementById('puzzleUI').style.display = 'block';
            }
            if (level === 3) {
                document.getElementById('racePosition').style.display = 'block';
                document.getElementById('timer').style.display = 'block';
            }

            // Show episode title
            const episodeTitle = document.getElementById('episodeTitle');
            episodeTitle.querySelector('h2').textContent = `EPISODE ${['', 'I', 'II', 'III', 'FINAL'][level]}`;
            episodeTitle.querySelector('h1').textContent = levelNames[level];
            episodeTitle.style.display = 'block';
            episodeTitle.style.opacity = '1';
            episodeTitle.style.animation = 'fadeIn 0.5s ease-out';

            // Hide episode title after 2 seconds using setTimeout and CSS
            setTimeout(() => {
                episodeTitle.style.animation = 'fadeOut 1s forwards';
                setTimeout(() => {
                    episodeTitle.style.display = 'none';
                }, 1000);
            }, 2000);

            // Play level intro
            const intros = ['', 'level1Intro', 'level2Intro', 'level3Intro', 'bossIntro'];
            playCutscene(intros[level], () => {
                // Cutscene callback - level already created
            });
        }

        function levelComplete() {
            currentState = GameState.LEVEL_COMPLETE;

            // Play completion cutscene
            const completes = ['', 'level1Complete', 'level2Complete', 'level3Complete'];

            if (currentLevel < 4) {
                playCutscene(completes[currentLevel], () => {
                    document.getElementById('levelComplete').style.display = 'flex';
                    document.getElementById('completeMessage').textContent =
                        currentLevel === 3 ? 'The final battle awaits...' : 'Prepare for the next challenge.';
                });
            }
        }

        function continueToNextLevel() {
            document.getElementById('levelComplete').style.display = 'none';
            startLevel(currentLevel + 1);
        }

        function gameOver() {
            currentState = GameState.GAME_OVER;
            document.getElementById('gameOver').style.display = 'flex';
            document.getElementById('hud').style.display = 'none';
            
            // Update death stats
            const levelNames = ['', 'I', 'II', 'III', 'IV'];
            document.getElementById('deathLevel').textContent = levelNames[currentLevel] || 'Unknown';
            document.getElementById('deathCoins').textContent = coinsCollected;
            document.getElementById('deathScore').textContent = score;
            
            // Set contextual death message
            const deathMessages = {
                1: {
                    title: "LOST IN DARKNESS",
                    messages: [
                        "The tunnels have claimed another victim. Your light fades into the eternal darkness...",
                        "Even the strongest ants can fall in the treacherous depths below...",
                        "The colony weeps, but your sacrifice will not be forgotten...",
                        "In the deep tunnels, even the brave can lose their way..."
                    ]
                },
                2: {
                    title: "PUZZLED TO DEATH",
                    messages: [
                        "The ancient crystals have shattered your hopes. The riddles remain unsolved...",
                        "Your mind was sharp, but the puzzles of the ancients proved too much...",
                        "The crystal chamber guards its secrets well. Another soul claimed...",
                        "In the halls of riddles, even the cleverest can meet their end..."
                    ]
                },
                3: {
                    title: "LEFT BEHIND",
                    messages: [
                        "The fire ants surge ahead. Queen Sita's fate grows darker with your fall...",
                        "You raced with courage, but the darkness was faster. The colony's hope dims...",
                        "In the race against time, you stumbled. The enemy advances...",
                        "The tunnels echo with the footsteps of your pursuers. You've been left behind..."
                    ]
                },
                4: {
                    title: "FALLEN TO RAVANA",
                    messages: [
                        "General Ravana stands victorious over your broken body. The kingdom's last hope dies...",
                        "The Fire Ant King proves too powerful. Your quest ends in flames and defeat...",
                        "In the throne room of darkness, your light is extinguished. Anthera weeps...",
                        "Against the might of Ravana, even the bravest ant cannot stand. All is lost..."
                    ]
                }
            };
            
            const levelDeath = deathMessages[currentLevel] || deathMessages[1];
            const randomMessage = levelDeath.messages[Math.floor(Math.random() * levelDeath.messages.length)];
            
            document.getElementById('deathTitle').textContent = "You Died";
            document.getElementById('deathMessage').textContent = randomMessage;
            
            camera.addShake(10, 0.5);
            MusicEngine.play('gameOver');
        }

        function victory() {
            currentState = GameState.VICTORY;
            document.getElementById('bossHealth').style.display = 'none';
            document.getElementById('hud').style.display = 'none';
            MusicEngine.play('victory');

            // Epic victory effects - immediate
            camera.addShake(15, 1);
            for (let i = 0; i < 20; i++) {
                spawnParticles(
                    player.x + Math.random() * 200 - 100,
                    player.y + Math.random() * 200 - 100,
                    5, Colors.gold, 150, 4, 2, -50
                );
            }

            // Show victory screen immediately
            document.getElementById('victory').style.display = 'flex';
        }

        function retryLevel() {
            document.getElementById('gameOver').style.display = 'none';
            startLevel(currentLevel);
        }

        function skipCurrentLevel() {
            if (currentState !== GameState.PLAYING) return;

            // Show custom confirmation modal
            document.getElementById('skipConfirmModal').style.display = 'flex';
            currentState = GameState.PAUSED;
        }

        function confirmSkipLevel() {
            // Hide modal
            document.getElementById('skipConfirmModal').style.display = 'none';

            // Add bonus points for skipping (less than completing)
            score += 100;
            updateHUD();

            // Go to next level or victory
            if (currentLevel < 4) {
                levelComplete();
            } else {
                victory();
            }
        }

        function cancelSkipLevel() {
            // Hide modal and resume game
            document.getElementById('skipConfirmModal').style.display = 'none';
            currentState = GameState.PLAYING;
        }

        function returnToMenu() {
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('victory').style.display = 'none';
            showTitleScreen();
        }

        function showStory() {
            playCutscene('intro', showTitleScreen);
        }

        // ==================== EVENT LISTENERS ====================
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM loaded, attaching event listeners");

            document.getElementById('storyBtn').addEventListener('click', () => {
                console.log("Story button clicked");
                showStory();
            });
            document.getElementById('startBtn').addEventListener('click', () => {
                console.log("Start button clicked");
                startGame();
            });
            document.getElementById('closeControls').addEventListener('click', hideControls);
            document.getElementById('closeAbout').addEventListener('click', hideAbout);
            document.getElementById('continueBtn').addEventListener('click', continueToNextLevel);
            document.getElementById('retryBtn').addEventListener('click', retryLevel);
            document.getElementById('menuBtn').addEventListener('click', returnToMenu);
            document.getElementById('creditsBtn').addEventListener('click', returnToMenu);
            document.getElementById('skipBtn').addEventListener('click', endCutscene);
            document.getElementById('confirmSkip').addEventListener('click', confirmSkipLevel);
            document.getElementById('cancelSkip').addEventListener('click', cancelSkipLevel);
        });

        // Modal functions
        function showControls() {
            console.log("Showing controls modal");
            document.getElementById('controlsModal').style.display = 'flex';
        }

        function hideControls() {
            console.log("Hiding controls modal");
            document.getElementById('controlsModal').style.display = 'none';
        }

        function showAbout() {
            console.log("Showing about modal");
            document.getElementById('aboutModal').style.display = 'flex';
        }

        function hideAbout() {
            console.log("Hiding about modal");
            document.getElementById('aboutModal').style.display = 'none';
        }

        // Cutscene advance
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && currentState === GameState.CUTSCENE) {
                advanceCutscene();
            }
        });

        document.getElementById('cutsceneOverlay').addEventListener('click', () => {
            if (currentState === GameState.CUTSCENE) {
                advanceCutscene();
            }
        });

        // ==================== INITIALIZATION ====================
        function init() {
            // Simulate loading
            setTimeout(() => {
                Assets.loaded = true;
                showTitleScreen();
            }, 2000);

            // Start game loop
            requestAnimationFrame(gameLoop);
        }
        init();
    </script>
</body>

</html>