<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beneath The Surface - The Legend of Anthera</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Uncial+Antiqua&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Cinzel', serif;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            background: #0a0a0f;
            image-rendering: pixelated;
        }

        /* Title Screen */
        #titleScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            animation: fadeIn 1s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        #titleScreen h1 {
            font-family: 'Uncial Antiqua', cursive;
            font-size: 4rem;
            color: #ffd700;
            text-shadow: 0 0 20px #ff6b00, 0 0 40px #ff4500, 0 0 60px #ff0000;
            margin-bottom: 10px;
            animation: flicker 3s infinite;
        }

        #titleScreen h2 {
            font-size: 1.5rem;
            color: #8b7355;
            margin-bottom: 50px;
            letter-spacing: 8px;
        }

        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
            52% { opacity: 1; }
            54% { opacity: 0.9; }
        }

        .menuBtn {
            font-family: 'Cinzel', serif;
            font-size: 1.2rem;
            padding: 15px 60px;
            margin: 10px;
            background: linear-gradient(180deg, #2a2a3e 0%, #1a1a2e 100%);
            border: 2px solid #ffd700;
            color: #ffd700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 3px;
        }

        .menuBtn:hover {
            background: linear-gradient(180deg, #ffd700 0%, #ff8c00 100%);
            color: #1a1a2e;
            box-shadow: 0 0 30px #ffd700;
            transform: scale(1.05);
        }

        /* Cutscene Overlay */
        #cutsceneOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: 200;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }

        #cutsceneText {
            color: #fff;
            font-size: 1.4rem;
            text-align: center;
            max-width: 800px;
            line-height: 2;
            padding: 20px;
        }

        #cutsceneImage {
            width: 400px;
            height: 300px;
            margin-bottom: 30px;
            border: 3px solid #ffd700;
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #skipBtn {
            position: absolute;
            bottom: 30px;
            right: 30px;
            font-family: 'Cinzel', serif;
            padding: 10px 30px;
            background: transparent;
            border: 1px solid #666;
            color: #666;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #skipBtn:hover {
            border-color: #ffd700;
            color: #ffd700;
        }

        #continuePrompt {
            position: absolute;
            bottom: 80px;
            color: #ffd700;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            display: none;
            justify-content: space-between;
            align-items: flex-start;
            z-index: 50;
            pointer-events: none;
        }

        #healthBar {
            width: 200px;
            height: 20px;
            background: #333;
            border: 2px solid #ffd700;
            border-radius: 10px;
            overflow: hidden;
        }

        #healthFill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff4500);
            transition: width 0.3s ease;
        }

        #levelInfo {
            color: #ffd700;
            text-align: right;
        }

        #levelInfo h3 {
            font-size: 1rem;
            margin-bottom: 5px;
        }

        #timer {
            font-size: 2rem;
            color: #ff4500;
            display: none;
        }

        /* Cinematic Bars */
        .cinematicBar {
            position: absolute;
            left: 0;
            width: 100%;
            height: 60px;
            background: #000;
            z-index: 150;
            transition: height 0.5s ease;
        }

        #topBar { top: 0; }
        #bottomBar { bottom: 0; }

        /* Dialogue Box */
        #dialogueBox {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 900px;
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #ffd700;
            padding: 20px 30px;
            display: none;
            z-index: 160;
        }

        #speakerName {
            color: #ffd700;
            font-size: 1rem;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #dialogueText {
            color: #fff;
            font-size: 1.1rem;
            line-height: 1.6;
        }

        /* Level Complete Screen */
        #levelComplete {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 180;
        }

        #levelComplete h2 {
            font-size: 3rem;
            color: #ffd700;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ff6b00;
        }

        #levelComplete p {
            color: #fff;
            font-size: 1.2rem;
            margin-bottom: 30px;
        }

        /* Game Over Screen */
        #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(50, 0, 0, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 190;
        }

        #gameOver h2 {
            font-size: 4rem;
            color: #ff0000;
            margin-bottom: 20px;
            text-shadow: 0 0 20px #ff0000;
        }

        /* Victory Screen */
        #victory {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #0a0a0f 0%, #1a1a2e 50%, #2a1a0e 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        #victory h2 {
            font-size: 3rem;
            color: #ffd700;
            margin-bottom: 20px;
            text-shadow: 0 0 30px #ffd700;
        }

        #victory p {
            color: #fff;
            font-size: 1.2rem;
            text-align: center;
            max-width: 600px;
            line-height: 1.8;
            margin-bottom: 30px;
        }

        /* Loading Screen */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }

        #loading h3 {
            color: #ffd700;
            margin-bottom: 20px;
        }

        .loadingBar {
            width: 300px;
            height: 10px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
        }

        .loadingFill {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ff8c00);
            animation: loading 2s ease-in-out forwards;
        }

        @keyframes loading {
            to { width: 100%; }
        }

        /* Controls Help */
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #666;
            font-size: 0.8rem;
            z-index: 50;
            pointer-events: none;
        }

        /* Puzzle UI */
        #puzzleUI {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffd700;
            font-size: 1rem;
            text-align: center;
            display: none;
            z-index: 50;
        }

        /* Boss Health Bar */
        #bossHealth {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            max-width: 500px;
            display: none;
            z-index: 50;
        }

        #bossName {
            color: #ff0000;
            text-align: center;
            margin-bottom: 5px;
            font-size: 1.2rem;
            text-shadow: 0 0 10px #ff0000;
        }

        #bossHealthBar {
            width: 100%;
            height: 15px;
            background: #333;
            border: 2px solid #ff0000;
            border-radius: 7px;
            overflow: hidden;
        }

        #bossHealthFill {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #8b0000, #ff0000);
            transition: width 0.3s ease;
        }

        /* Episode Title */
        #episodeTitle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 170;
            display: none;
        }

        #episodeTitle h2 {
            font-size: 1.5rem;
            color: #888;
            letter-spacing: 5px;
            margin-bottom: 10px;
        }

        #episodeTitle h1 {
            font-family: 'Uncial Antiqua', cursive;
            font-size: 3rem;
            color: #ffd700;
            text-shadow: 0 0 20px #ff6b00;
        }

        /* Torch glow effect */
        .torchGlow {
            position: absolute;
            width: 200px;
            height: 200px;
            background: radial-gradient(circle, rgba(255, 150, 50, 0.3) 0%, transparent 70%);
            pointer-events: none;
            animation: torchFlicker 0.5s infinite;
        }

        @keyframes torchFlicker {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(0.95); }
        }

        /* Race Position Indicator */
        #racePosition {
            position: absolute;
            top: 80px;
            right: 20px;
            color: #ffd700;
            font-size: 2rem;
            display: none;
            z-index: 50;
        }

        /* Particles container */
        #particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 45;
        }

        /* Modal Styles */
        .modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }

        .modalContent {
            background: linear-gradient(180deg, #1a1a2e 0%, #16213e 100%);
            border: 3px solid #ffd700;
            border-radius: 15px;
            padding: 40px;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.3);
        }

        .modalContent h2 {
            font-family: 'Uncial Antiqua', cursive;
            font-size: 2rem;
            color: #ffd700;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #ff6b00;
        }

        .modalContent p {
            color: #fff;
            font-size: 1.1rem;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .controlsList {
            margin: 30px 0;
        }

        .controlItem {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .key {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid #ffd700;
        }

        .action {
            color: #fff;
            font-size: 1rem;
        }

        /* Enhanced menu buttons */
        .menuBtn {
            font-family: 'Cinzel', serif;
            font-size: 1.2rem;
            padding: 15px 60px;
            margin: 10px;
            background: linear-gradient(180deg, #2a2a3e 0%, #1a1a2e 100%);
            border: 2px solid #ffd700;
            color: #ffd700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 3px;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .menuBtn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 215, 0, 0.3), transparent);
            transition: left 0.5s ease;
        }

        .menuBtn:hover::before {
            left: 100%;
        }

        .menuBtn:hover {
            background: linear-gradient(180deg, #ffd700 0%, #ff8c00 100%);
            color: #1a1a2e;
            box-shadow: 0 0 30px #ffd700;
            transform: scale(1.05);
        }

        /* Enhanced title screen */
        #titleScreen {
            background: linear-gradient(180deg, #0a0a0f 0%, #1a1a2e 50%, #16213e 100%);
        }

        #titleScreen h1 {
            font-family: 'Uncial Antiqua', cursive;
            font-size: 4rem;
            color: #ffd700;
            text-shadow: 0 0 20px #ff6b00, 0 0 40px #ff4500, 0 0 60px #ff0000;
            margin-bottom: 10px;
            animation: flicker 3s infinite;
        }

        #titleScreen h2 {
            font-size: 1.5rem;
            color: #8b7355;
            margin-bottom: 50px;
            letter-spacing: 8px;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <!-- Loading Screen -->
        <div id="loading">
            <h3>LOADING...</h3>
            <div class="loadingBar">
                <div class="loadingFill"></div>
            </div>
        </div>

        <!-- Title Screen -->
        <div id="titleScreen" style="display: none;">
            <h1>BENEATH THE SURFACE</h1>
            <h2>THE ANTHERA CHRONICLES</h2>
            <button class="menuBtn" id="startBtn">Begin Journey</button>
            <button class="menuBtn" id="storyBtn">The Story</button>
            <button class="menuBtn" id="controlsBtn">Controls</button>
            <button class="menuBtn" id="aboutBtn">About</button>
        </div>

        <!-- Cutscene Overlay -->
        <div id="cutsceneOverlay">
            <div id="cutsceneImage"></div>
            <div id="cutsceneText"></div>
            <div id="continuePrompt">Press SPACE or CLICK to continue</div>
            <button id="skipBtn">SKIP</button>
        </div>

        <!-- Cinematic Bars -->
        <div id="topBar" class="cinematicBar" style="height: 0;"></div>
        <div id="bottomBar" class="cinematicBar" style="height: 0;"></div>

        <!-- HUD -->
        <div id="hud">
            <div>
                <div id="healthBar">
                    <div id="healthFill"></div>
                </div>
                <div id="timer"></div>
            </div>
            <div id="levelInfo">
                <h3 id="levelName">EPISODE I</h3>
                <p id="levelSubtitle">The Descent</p>
            </div>
        </div>

        <!-- Dialogue Box -->
        <div id="dialogueBox">
            <div id="speakerName"></div>
            <div id="dialogueText"></div>
        </div>

        <!-- Episode Title -->
        <div id="episodeTitle">
            <h2>EPISODE I</h2>
            <h1>The Descent</h1>
        </div>

        <!-- Puzzle UI -->
        <div id="puzzleUI">
            <p id="puzzleHint">Find the ancient switches to unlock the path</p>
        </div>

        <!-- Race Position -->
        <div id="racePosition">1st</div>

        <!-- Boss Health -->
        <div id="bossHealth">
            <div id="bossName">GENERAL RAVANA</div>
            <div id="bossHealthBar">
                <div id="bossHealthFill"></div>
            </div>
        </div>

        <!-- Level Complete -->
        <div id="levelComplete">
            <h2>EPISODE COMPLETE</h2>
            <p id="completeMessage">You have proven your worth, soldier.</p>
            <button class="menuBtn" id="continueBtn">Continue</button>
        </div>

        <!-- Game Over -->
        <div id="gameOver">
            <h2>FALLEN</h2>
            <p>The kingdom's hope fades...</p>
            <button class="menuBtn" id="retryBtn">Rise Again</button>
            <button class="menuBtn" id="menuBtn">Return to Menu</button>
        </div>

        <!-- Victory Screen -->
        <div id="victory">
            <h2>üèÜ VICTORY üèÜ</h2>
            <p>Against all odds, you have defeated General Ravana and rescued Queen Sita. The kingdom of Anthera shall forever sing of your bravery. From the depths beneath the surface, a hero has risen.</p>
            <button class="menuBtn" id="creditsBtn">The End</button>
        </div>

        <!-- Controls -->
        <div id="controls">
            <p>ARROWS/WASD: Move | SPACE: Jump | E: Interact | SHIFT: Sprint</p>
        </div>

        <!-- Controls Modal -->
        <div id="controlsModal" style="display: none;">
            <div class="modalContent">
                <h2>GAME CONTROLS</h2>
                <div class="controlsList">
                    <div class="controlItem">
                        <span class="key">ARROWS / WASD</span>
                        <span class="action">Move your ant</span>
                    </div>
                    <div class="controlItem">
                        <span class="key">SPACE / W / ‚Üë</span>
                        <span class="action">Jump</span>
                    </div>
                    <div class="controlItem">
                        <span class="key">E</span>
                        <span class="action">Interact with objects</span>
                    </div>
                    <div class="controlItem">
                        <span class="key">SHIFT</span>
                        <span class="action">Sprint (faster movement)</span>
                    </div>
                    <div class="controlItem">
                        <span class="key">X / Z</span>
                        <span class="action">Attack with your weapon</span>
                    </div>
                </div>
                <button class="menuBtn" id="closeControls">Back</button>
            </div>
        </div>

        <!-- About Modal -->
        <div id="aboutModal" style="display: none;">
            <div class="modalContent">
                <h2>ABOUT THE ANTHERA CHRONICLES</h2>
                <p>
                    Embark on an epic underground adventure as a brave worker ant on a mission to save your Queen and colony.
                    Navigate through treacherous tunnels, solve ancient puzzles, and battle rival fire ants in this underground platformer.
                </p>
                <p>
                    Experience a rich story of courage, sacrifice, and the unbreakable spirit of the ant colony.
                    Will you be able to rescue Queen Sita and restore peace to Anthera?
                </p>
                <button class="menuBtn" id="closeAbout">Back</button>
            </div>
        </div>
    </div>

    <script>
// ==================== GAME ENGINE ====================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Set canvas size
function resizeCanvas() {
    canvas.width = Math.min(window.innerWidth, 1280);
    canvas.height = Math.min(window.innerHeight, 720);
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

// ==================== GAME STATE ====================
const GameState = {
    LOADING: 'loading',
    MENU: 'menu',
    CUTSCENE: 'cutscene',
    PLAYING: 'playing',
    PAUSED: 'paused',
    LEVEL_COMPLETE: 'levelComplete',
    GAME_OVER: 'gameOver',
    VICTORY: 'victory'
};

let currentState = GameState.LOADING;
let currentLevel = 0;
let gameTime = 0;
let deltaTime = 0;
let lastTime = 0;

// ==================== ASSETS ====================
const Assets = {
    loaded: false,
    images: {},
    sounds: {}
};

// Enhanced underground color palette
const Colors = {
    background: '#0a0a0f',
    caveDark: '#1a1a2e',
    caveMid: '#2d2d44',
    caveLight: '#3d3d5c',
    rock: '#4a4a6a',
    rockLight: '#5a5a7a',
    soil: '#3a2818',
    soilDark: '#2a1810',
    soilLight: '#4a3828',
    dirt: '#5a4838',
    dirtDark: '#4a3828',
    dirtLight: '#6a5848',
    stone: '#6a6a7a',
    stoneDark: '#4a4a5a',
    stoneLight: '#8a8a9a',
    clay: '#7a4a3a',
    lava: '#ff4500',
    lavaGlow: '#ff6b00',
    crystal: '#00ffff',
    crystalGlow: '#00cccc',
    gold: '#ffd700',
    torch: '#ff9932',
    player: '#4a90d9',
    enemy: '#d94a4a',
    platform: '#3d3d5c',
    spike: '#8b0000',
    water: '#1a4a6a',
    roots: '#4a3a2a',
    moss: '#3a4a3a',
    fungi: '#6a4a6a'
};

// ==================== PARTICLE SYSTEM ====================
class Particle {
    constructor(x, y, vx, vy, color, size, life, gravity = 0) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.size = size;
        this.life = life;
        this.maxLife = life;
        this.gravity = gravity;
    }

    update(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        this.vy += this.gravity * dt;
        this.life -= dt;
    }

    draw(ctx, camera) {
        const alpha = this.life / this.maxLife;
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x - camera.x, this.y - camera.y, this.size * alpha, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

const particles = [];

function spawnParticles(x, y, count, color, speed = 100, size = 3, life = 1, gravity = 0) {
    for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const vel = Math.random() * speed;
        particles.push(new Particle(
            x, y,
            Math.cos(angle) * vel,
            Math.sin(angle) * vel,
            color,
            Math.random() * size + 1,
            Math.random() * life + 0.5,
            gravity
        ));
    }
}

function updateParticles(dt) {
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update(dt);
        if (particles[i].life <= 0) {
            particles.splice(i, 1);
        }
    }
}

function drawParticles(ctx, camera) {
    particles.forEach(p => p.draw(ctx, camera));
}

// ==================== CAMERA ====================
const camera = {
    x: 0,
    y: 0,
    targetX: 0,
    targetY: 0,
    shake: 0,
    shakeIntensity: 0,
    
    follow(target, levelWidth, levelHeight) {
        this.targetX = target.x - canvas.width / 2 + target.width / 2;
        this.targetY = target.y - canvas.height / 2 + target.height / 2;
        
        // Smooth follow
        this.x += (this.targetX - this.x) * 0.1;
        this.y += (this.targetY - this.y) * 0.1;
        
        // Bounds
        this.x = Math.max(0, Math.min(this.x, levelWidth - canvas.width));
        this.y = Math.max(0, Math.min(this.y, levelHeight - canvas.height));
        
        // Screen shake
        if (this.shake > 0) {
            this.x += (Math.random() - 0.5) * this.shakeIntensity;
            this.y += (Math.random() - 0.5) * this.shakeIntensity;
            this.shake -= deltaTime;
        }
    },
    
    addShake(intensity, duration) {
        this.shake = duration;
        this.shakeIntensity = intensity;
    }
};

// ==================== INPUT ====================
const keys = {};
window.addEventListener('keydown', e => {
    keys[e.code] = true;
    if (e.code === 'Space') e.preventDefault();
});
window.addEventListener('keyup', e => keys[e.code] = false);

// ==================== PLAYER ====================
class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 32;
        this.height = 48;
        this.vx = 0;
        this.vy = 0;
        this.speed = 250;
        this.sprintSpeed = 400;
        this.jumpForce = -450;
        this.gravity = 1200;
        this.grounded = false;
        this.health = 100;
        this.maxHealth = 100;
        this.invincible = 0;
        this.facing = 1;
        this.animFrame = 0;
        this.animTimer = 0;
        this.attacking = false;
        this.attackTimer = 0;
        this.attackCooldown = 0;
        this.canDoubleJump = false;
        this.hasDoubleJumped = false;
    }

    update(dt, platforms, hazards, enemies) {
        // Invincibility timer
        if (this.invincible > 0) this.invincible -= dt;
        if (this.attackCooldown > 0) this.attackCooldown -= dt;
        
        // Input
        let moveX = 0;
        if (keys['ArrowLeft'] || keys['KeyA']) moveX = -1;
        if (keys['ArrowRight'] || keys['KeyD']) moveX = 1;
        
        const sprinting = keys['ShiftLeft'] || keys['ShiftRight'];
        const currentSpeed = sprinting ? this.sprintSpeed : this.speed;
        
        this.vx = moveX * currentSpeed;
        if (moveX !== 0) this.facing = moveX;
        
        // Jump
        if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && this.grounded) {
            this.vy = this.jumpForce;
            this.grounded = false;
            this.hasDoubleJumped = false;
            spawnParticles(this.x + this.width/2, this.y + this.height, 5, Colors.caveMid, 50, 2, 0.3, 200);
        } else if ((keys['Space'] || keys['ArrowUp'] || keys['KeyW']) && this.canDoubleJump && !this.hasDoubleJumped && !this.grounded) {
            if (!keys['_jumpReleased']) {
                // Wait for key release
            } else {
                this.vy = this.jumpForce * 0.8;
                this.hasDoubleJumped = true;
                spawnParticles(this.x + this.width/2, this.y + this.height/2, 8, Colors.crystal, 80, 2, 0.5, 0);
            }
        }
        
        if (!keys['Space'] && !keys['ArrowUp'] && !keys['KeyW']) {
            keys['_jumpReleased'] = true;
        } else if (this.grounded) {
            keys['_jumpReleased'] = false;
        }
        
        // Attack
        if (keys['KeyX'] || keys['KeyZ']) {
            if (this.attackCooldown <= 0 && !this.attacking) {
                this.attacking = true;
                this.attackTimer = 0.3;
                this.attackCooldown = 0.5;
                
                // Shoot bullets in boss fight
                if (currentLevel === 4) {
                    this.shootBullet();
                }
            }
        }
        
        if (this.attacking) {
            this.attackTimer -= dt;
            if (this.attackTimer <= 0) this.attacking = false;
        }
        
        // Gravity
        this.vy += this.gravity * dt;
        if (this.vy > 800) this.vy = 800;
        
        // Move X
        this.x += this.vx * dt;
        this.grounded = false;
        
        // Platform collision X
        for (const p of platforms) {
            if (this.collides(p)) {
                if (this.vx > 0) this.x = p.x - this.width;
                else if (this.vx < 0) this.x = p.x + p.width;
            }
        }
        
        // Move Y
        this.y += this.vy * dt;
        
        // Platform collision Y
        for (const p of platforms) {
            if (this.collides(p)) {
                if (this.vy > 0) {
                    this.y = p.y - this.height;
                    this.vy = 0;
                    this.grounded = true;
                    this.hasDoubleJumped = false;
                } else if (this.vy < 0) {
                    this.y = p.y + p.height;
                    this.vy = 0;
                }
            }
        }
        
        // Hazard collision
        for (const h of hazards) {
            if (this.collides(h) && this.invincible <= 0) {
                this.takeDamage(h.damage || 20);
            }
        }
        
        // Enemy collision (for attacking)
        if (this.attacking) {
            const attackBox = {
                x: this.facing > 0 ? this.x + this.width : this.x - 40,
                y: this.y,
                width: 40,
                height: this.height
            };
            for (const e of enemies) {
                if (this.boxCollides(attackBox, e) && !e.dead) {
                    e.takeDamage(25);
                    camera.addShake(3, 0.1);
                    spawnParticles(e.x + e.width/2, e.y + e.height/2, 10, Colors.enemy, 100, 3, 0.5, 100);
                }
            }
        }
        
        // Animation
        this.animTimer += dt;
        if (this.animTimer > 0.1) {
            this.animTimer = 0;
            this.animFrame = (this.animFrame + 1) % 4;
        }
        
        // Running particles
        if (this.grounded && Math.abs(this.vx) > 100) {
            if (Math.random() < 0.3) {
                spawnParticles(this.x + this.width/2, this.y + this.height, 1, Colors.caveMid, 30, 2, 0.3, 100);
            }
        }
    }

    takeDamage(amount) {
        if (this.invincible > 0) return;
        this.health -= amount;
        this.invincible = 1;
        camera.addShake(5, 0.2);
        spawnParticles(this.x + this.width/2, this.y + this.height/2, 15, '#ff0000', 150, 4, 0.5, 200);
        document.getElementById('healthFill').style.width = (this.health / this.maxHealth * 100) + '%';
        
        if (this.health <= 0) {
            this.health = 0;
            gameOver();
        }
    }

    heal(amount) {
        this.health = Math.min(this.maxHealth, this.health + amount);
        document.getElementById('healthFill').style.width = (this.health / this.maxHealth * 100) + '%';
        spawnParticles(this.x + this.width/2, this.y + this.height/2, 10, '#00ff00', 80, 3, 0.5, -50);
    }
    
    shootBullet() {
        // Create player bullet
        const bullet = {
            x: this.x + this.width/2,
            y: this.y + this.height/2,
            vx: this.facing > 0 ? 400 : -400,
            vy: 0,
            width: 12,
            height: 6,
            damage: 10,
            lifetime: 2,
            isPlayerBullet: true
        };
        
        if (!this.bullets) this.bullets = [];
        this.bullets.push(bullet);
        
        // Visual effect
        spawnParticles(this.x + this.width/2, this.y + this.height/2, 5, '#00ffff', 60, 2, 0.5, 0);
    }

    collides(other) {
        return this.x < other.x + other.width &&
               this.x + this.width > other.x &&
               this.y < other.y + other.height &&
               this.y + this.height > other.y;
    }
    
    boxCollides(a, b) {
        return a.x < b.x + b.width &&
               a.x + a.width > b.x &&
               a.y < b.y + b.height &&
               a.y + a.height > b.y;
    }

    draw(ctx, camera) {
        const screenX = this.x - camera.x;
        const screenY = this.y - camera.y;
        
        // Flash when invincible
        if (this.invincible > 0 && Math.floor(this.invincible * 10) % 2 === 0) {
            ctx.globalAlpha = 0.5;
        }
        
        // Ant body segments
        const bodyColor = '#2a2a2a';
        const segmentColor = '#1a1a1a';
        
        // Head (rounded)
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(screenX + this.width/2, screenY + 8, 10, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Thorax (middle segment)
        ctx.fillStyle = segmentColor;
        ctx.beginPath();
        ctx.ellipse(screenX + this.width/2, screenY + 18, 8, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Abdomen (back segment - larger)
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(screenX + this.width/2, screenY + 30, 12, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Antennae
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        // Left antenna
        ctx.moveTo(screenX + this.width/2 - 4, screenY + 6);
        ctx.quadraticCurveTo(screenX + this.width/2 - 8, screenY - 2, screenX + this.width/2 - 6, screenY - 6);
        // Right antenna
        ctx.moveTo(screenX + this.width/2 + 4, screenY + 6);
        ctx.quadraticCurveTo(screenX + this.width/2 + 8, screenY - 2, screenX + this.width/2 + 6, screenY - 6);
        ctx.stroke();
        
        // Eyes
        ctx.fillStyle = '#ff0000';
        ctx.beginPath();
        ctx.arc(screenX + this.width/2 - 3, screenY + 6, 2, 0, Math.PI * 2);
        ctx.arc(screenX + this.width/2 + 3, screenY + 6, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Legs (6 legs - 3 per side) with improved animation
        ctx.strokeStyle = bodyColor;
        ctx.lineWidth = 2;
        
        // Enhanced leg animation based on movement
        const legMoveSpeed = Math.abs(this.vx) > 50 ? 0.3 : 0.1;
        const legOffset = Math.sin(this.animFrame * legMoveSpeed) * 3;
        
        // Left legs
        for (let i = 0; i < 3; i++) {
            const legY = screenY + 12 + i * 8;
            ctx.beginPath();
            ctx.moveTo(screenX + 4, legY);
            ctx.lineTo(screenX - 4, legY + 4 + legOffset);
            ctx.lineTo(screenX - 2, legY + 8 + legOffset);
            ctx.stroke();
        }
        
        // Right legs
        for (let i = 0; i < 3; i++) {
            const legY = screenY + 12 + i * 8;
            ctx.beginPath();
            ctx.moveTo(screenX + this.width - 4, legY);
            ctx.lineTo(screenX + this.width + 4, legY + 4 - legOffset);
            ctx.lineTo(screenX + this.width + 2, legY + 8 - legOffset);
            ctx.stroke();
        }
        
        // Body bounce animation when grounded
        const bodyBounce = this.grounded ? Math.sin(this.animFrame * 0.2) * 1 : 0;
        
        // Redraw body segments with bounce
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(screenX + this.width/2, screenY + 8 + bodyBounce, 10, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = segmentColor;
        ctx.beginPath();
        ctx.ellipse(screenX + this.width/2, screenY + 18 + bodyBounce, 8, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(screenX + this.width/2, screenY + 30 + bodyBounce, 12, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Sword (when attacking)
        if (this.attacking) {
            ctx.fillStyle = '#8b4513'; // Wooden sword theme
            ctx.save();
            ctx.translate(screenX + this.width/2, screenY + this.height/2);
            ctx.rotate(this.facing > 0 ? -0.5 + this.attackTimer * 5 : 0.5 - this.attackTimer * 5);
            ctx.fillRect(0, -2, 30 * this.facing, 4);
            ctx.fillStyle = '#654321';
            ctx.fillRect(0, -3, 6 * this.facing, 6);
            ctx.restore();
        } else {
            // Sword at rest (small wooden dagger)
            ctx.fillStyle = '#8b4513';
            ctx.fillRect(screenX + (this.facing > 0 ? 20 : -4), screenY + 15, 4, 15);
            ctx.fillStyle = '#654321';
            ctx.fillRect(screenX + (this.facing > 0 ? 18 : -2), screenY + 13, 8, 4);
        }
        
        ctx.globalAlpha = 1;
    }
}

// ==================== ENEMY ====================
class Enemy {
    constructor(x, y, type = 'soldier') {
        this.x = x;
        this.y = y;
        this.type = type;
        this.width = type === 'boss' ? 64 : 32;
        this.height = type === 'boss' ? 80 : 48;
        this.vx = 0;
        this.vy = 0;
        this.speed = type === 'boss' ? 150 : 80;
        this.health = type === 'boss' ? 500 : 50;
        this.maxHealth = this.health;
        this.gravity = 1200;
        this.grounded = false;
        this.facing = -1;
        this.dead = false;
        this.animFrame = 0;
        this.animTimer = 0;
        this.attackTimer = 0;
        this.attackCooldown = type === 'boss' ? 2 : 1.5;
        this.patrolDir = 1;
        this.patrolTimer = 0;
        this.patrolDuration = 2;
        this.state = 'patrol'; // patrol, chase, attack
        this.detectionRange = type === 'boss' ? 400 : 200;
        this.attackRange = type === 'boss' ? 80 : 50;
        
        // Boss specific
        this.bossPhase = 1;
        this.specialAttackTimer = 0;
    }

    update(dt, player, platforms) {
        if (this.dead) return;
        
        this.attackTimer -= dt;
        this.animTimer += dt;
        
        // FIXED BOSS - doesn't move, just attacks
        if (this.fixed) {
            this.specialAttackTimer = (this.specialAttackTimer || 0) + dt;
            
            // Attack every 2 seconds
            if (this.specialAttackTimer > 2) {
                this.fixedAttack(player);
                this.specialAttackTimer = 0;
            }
            
            // Phase changes based on health
            if (this.health < this.maxHealth * 0.6 && this.bossPhase === 1) {
                this.bossPhase = 2;
                camera.addShake(10, 0.5);
                spawnParticles(this.x + this.width/2, this.y + this.height/2, 30, Colors.lava, 200, 5, 1, 100);
            }
            if (this.health < this.maxHealth * 0.3 && this.bossPhase === 2) {
                this.bossPhase = 3;
                camera.addShake(15, 0.5);
                spawnParticles(this.x + this.width/2, this.y + this.height/2, 50, Colors.lava, 250, 6, 1.5, 100);
            }
            return; // Skip regular enemy logic
        }
        
        // Regular enemy logic for non-fixed enemies
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // State machine
        if (dist < this.attackRange && Math.abs(dy) < 50) {
            this.state = 'attack';
        } else if (dist < this.detectionRange) {
            this.state = 'chase';
        } else {
            this.state = 'patrol';
        }
        
        // Behavior
        switch (this.state) {
            case 'patrol':
                this.patrolTimer += dt;
                if (this.patrolTimer > this.patrolDuration) {
                    this.patrolTimer = 0;
                    this.patrolDir *= -1;
                }
                this.vx = this.patrolDir * this.speed * 0.5;
                this.facing = this.patrolDir;
                break;
                
            case 'chase':
                this.vx = Math.sign(dx) * this.speed;
                this.facing = Math.sign(dx);
                break;
                
            case 'attack':
                this.vx = 0;
                this.facing = Math.sign(dx);
                if (this.attackTimer <= 0) {
                    this.attack(player);
                    this.attackTimer = this.attackCooldown;
                }
                break;
        }
        
        // Boss special attacks
        if (this.type === 'boss') {
            // Initialize timers if not set
            if (!this.specialAttackTimer) this.specialAttackTimer = 0;
            if (!this.attackTimer) this.attackTimer = 0;
            
            this.specialAttackTimer += dt;
            
            // Much more frequent attacks - every 1 second
            if (this.specialAttackTimer > 1) {
                console.log("Boss attacking!"); // Debug
                this.specialAttack(player);
                this.specialAttackTimer = 0;
            }
            
            // Also regular attacks when close
            if (this.state === 'attack' && this.attackTimer <= 0) {
                this.attack(player);
                this.attackTimer = this.attackCooldown;
            }
            
            // Phase changes
            if (this.health < this.maxHealth * 0.6 && this.bossPhase === 1) {
                this.bossPhase = 2;
                this.speed *= 1.3;
                this.attackCooldown *= 0.8;
                camera.addShake(10, 0.5);
                spawnParticles(this.x + this.width/2, this.y + this.height/2, 30, Colors.lava, 200, 5, 1, 100);
            }
            if (this.health < this.maxHealth * 0.3 && this.bossPhase === 2) {
                this.bossPhase = 3;
                this.speed *= 1.3;
                this.attackCooldown *= 0.7;
                camera.addShake(15, 0.5);
                spawnParticles(this.x + this.width/2, this.y + this.height/2, 50, Colors.lava, 250, 6, 1.5, 100);
            }
        }
        
        // Gravity
        this.vy += this.gravity * dt;
        if (this.vy > 800) this.vy = 800;
        
        // Movement
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        
        // Platform collision
        this.grounded = false;
        for (const p of platforms) {
            if (this.collides(p)) {
                if (this.vy > 0) {
                    this.y = p.y - this.height;
                    this.vy = 0;
                    this.grounded = true;
                } else if (this.vy < 0) {
                    this.y = p.y + p.height;
                    this.vy = 0;
                }
            }
        }
        
        // Animation
        if (Math.abs(this.vx) > 10) {
            this.animFrame += dt * 8;
        }
    }

    fixedAttack(player) {
        // Simple attack pattern for fixed boss - NO setTimeout
        const attackType = Math.floor(Math.random() * 3);
        
        switch (attackType) {
            case 0:
                // Fire projectiles at player - immediate
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                for (let i = 0; i < 3; i++) {
                    const spear = {
                        x: this.x + this.width/2,
                        y: this.y + this.height/2,
                        vx: (dx / dist) * 200,
                        vy: (dy / dist) * 200 - i * 50,
                        width: 15,
                        height: 8,
                        damage: 15,
                        lifetime: 3
                    };
                    
                    if (!this.spears) this.spears = [];
                    this.spears.push(spear);
                }
                spawnParticles(this.x + this.width/2, this.y + this.height/2, 10, Colors.lava, 100, 2, 0.5, 0);
                break;
                
            case 1:
                // Ground slam - immediate
                camera.addShake(8, 0.3);
                spawnParticles(this.x + this.width/2, this.y + this.height, 20, Colors.lava, 150, 4, 0.8, 200);
                
                // Damage if player is on ground nearby
                const playerDist = Math.abs(player.x - this.x);
                if (playerDist < 200 && player.grounded) {
                    player.takeDamage(20);
                }
                break;
                
            case 2:
                // Spread shot - immediate
                for (let i = 0; i < 5; i++) {
                    const angle = (i - 2) * 0.3;
                    const spear = {
                        x: this.x + this.width/2,
                        y: this.y + this.height/2,
                        vx: Math.cos(angle) * 200,
                        vy: Math.sin(angle) * 200 - 100,
                        width: 15,
                        height: 8,
                        damage: 15,
                        lifetime: 3
                    };
                    
                    if (!this.spears) this.spears = [];
                    this.spears.push(spear);
                }
                spawnParticles(this.x + this.width/2, this.y + this.height/2, 10, Colors.stone, 100, 2, 0.5, 0);
                break;
        }
    }
    
    specialAttack(player) {
        // DISABLED - Use fixedAttack instead to prevent freezing
        return;
    }
    
    attack(player) {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < this.attackRange + 20) {
            player.takeDamage(this.type === 'boss' ? 25 : 15);
        }
        
        spawnParticles(
            this.x + this.width/2 + this.facing * 30,
            this.y + this.height/2,
            5, '#ff4444', 80, 3, 0.3, 0
        );
    }

    takeDamage(amount) {
        if (this.dead) return;
        this.health -= amount;
        
        if (this.type === 'boss') {
            document.getElementById('bossHealthFill').style.width = 
                (this.health / this.maxHealth * 100) + '%';
        }
        
        if (this.health <= 0) {
            this.dead = true;
            spawnParticles(this.x + this.width/2, this.y + this.height/2, 30, Colors.enemy, 150, 5, 1, 200);
            
            if (this.type === 'boss') {
                victory();
            }
        }
    }

    collides(other) {
        return this.x < other.x + other.width &&
               this.x + this.width > other.x &&
               this.y < other.y + other.height &&
               this.y + this.height > other.y;
    }

    draw(ctx, cam) {
        if (this.dead) return;
        
        const screenX = this.x - cam.x;
        const screenY = this.y - cam.y;
        
        if (this.type === 'boss') {
            this.drawBoss(ctx, screenX, screenY);
        } else {
            this.drawSoldier(ctx, screenX, screenY);
        }
    }
    
    drawSoldier(ctx, screenX, screenY) {
        // Enemy ant soldier
        const bodyColor = '#4a1a1a'; // Darker red-brown
        const segmentColor = '#3a0a0a';
        
        // Head (more aggressive looking)
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(screenX + this.width/2, screenY + 8, 10, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Thorax
        ctx.fillStyle = segmentColor;
        ctx.beginPath();
        ctx.ellipse(screenX + this.width/2, screenY + 18, 8, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Abdomen (slightly larger for menacing look)
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(screenX + this.width/2, screenY + 30, 14, 11, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Antennae (more angular)
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(screenX + this.width/2 - 4, screenY + 6);
        ctx.lineTo(screenX + this.width/2 - 8, screenY - 4);
        ctx.moveTo(screenX + this.width/2 + 4, screenY + 6);
        ctx.lineTo(screenX + this.width/2 + 8, screenY - 4);
        ctx.stroke();
        
        // Evil red eyes
        ctx.fillStyle = '#ff0000';
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 3;
        ctx.beginPath();
        ctx.arc(screenX + this.width/2 - 3, screenY + 6, 2, 0, Math.PI * 2);
        ctx.arc(screenX + this.width/2 + 3, screenY + 6, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Legs (armored looking)
        ctx.strokeStyle = bodyColor;
        ctx.lineWidth = 3;
        
        const legOffset = Math.sin(this.animFrame * Math.PI / 2) * 3;
        
        // Left legs
        for (let i = 0; i < 3; i++) {
            const legY = screenY + 12 + i * 8;
            ctx.beginPath();
            ctx.moveTo(screenX + 4, legY);
            ctx.lineTo(screenX - 6, legY + 6 + legOffset);
            ctx.lineTo(screenX - 4, legY + 12 + legOffset);
            ctx.stroke();
        }
        
        // Right legs
        for (let i = 0; i < 3; i++) {
            const legY = screenY + 12 + i * 8;
            ctx.beginPath();
            ctx.moveTo(screenX + this.width - 4, legY);
            ctx.lineTo(screenX + this.width + 6, legY + 6 - legOffset);
            ctx.lineTo(screenX + this.width + 4, legY + 12 - legOffset);
            ctx.stroke();
        }
        
        // Weapon (spear)
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(screenX + (this.facing > 0 ? 26 : -8), screenY + 10, 6, 35);
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(screenX + (this.facing > 0 ? 24 : -6), screenY + 8, 10, 6);
    }
    
    drawBoss(ctx, screenX, screenY) {
        // Giant ant boss - General Ravana
        
        // Phase-based glow
        if (this.bossPhase >= 2) {
            ctx.fillStyle = `rgba(255, ${100 - this.bossPhase * 20}, 0, 0.3)`;
            ctx.beginPath();
            ctx.arc(screenX + this.width/2, screenY + this.height/2, 80, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Massive ant body
        const bodyColor = '#1a0a0a';
        const segmentColor = '#0f0505';
        
        // Giant head
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(screenX + this.width/2, screenY + 15, 20, 16, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Crown/helmet
        ctx.fillStyle = '#2a0a0a';
        ctx.fillRect(screenX + this.width/2 - 25, screenY - 5, 50, 15);
        ctx.fillStyle = Colors.lava;
        ctx.fillRect(screenX + this.width/2 - 15, screenY - 8, 10, 10);
        ctx.fillRect(screenX + this.width/2 + 5, screenY - 8, 10, 10);
        
        // Thorax
        ctx.fillStyle = segmentColor;
        ctx.beginPath();
        ctx.ellipse(screenX + this.width/2, screenY + 35, 16, 12, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Massive abdomen
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(screenX + this.width/2, screenY + 55, 28, 22, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Armor plates on abdomen
        ctx.fillStyle = '#3a1a1a';
        ctx.fillRect(screenX + this.width/2 - 20, screenY + 45, 40, 8);
        ctx.fillStyle = '#4a2a2a';
        ctx.fillRect(screenX + this.width/2 - 18, screenY + 47, 36, 4);
        
        // Giant menacing antennae
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(screenX + this.width/2 - 8, screenY + 10);
        ctx.lineTo(screenX + this.width/2 - 20, screenY - 10);
        ctx.moveTo(screenX + this.width/2 + 8, screenY + 10);
        ctx.lineTo(screenX + this.width/2 + 20, screenY - 10);
        ctx.stroke();
        
        // Glowing evil eyes
        ctx.fillStyle = this.bossPhase >= 3 ? '#ff0000' : '#ff6600';
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(screenX + this.width/2 - 8, screenY + 12, 4, 0, Math.PI * 2);
        ctx.arc(screenX + this.width/2 + 8, screenY + 12, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Six powerful legs
        ctx.strokeStyle = bodyColor;
        ctx.lineWidth = 5;
        
        const legOffset = Math.sin(this.animFrame * Math.PI / 2) * 8;
        
        // Left legs
        for (let i = 0; i < 3; i++) {
            const legY = screenY + 20 + i * 15;
            ctx.beginPath();
            ctx.moveTo(screenX + 8, legY);
            ctx.lineTo(screenX - 12, legY + 15 + legOffset);
            ctx.lineTo(screenX - 8, legY + 30 + legOffset);
            ctx.stroke();
        }
        
        // Right legs
        for (let i = 0; i < 3; i++) {
            const legY = screenY + 20 + i * 15;
            ctx.beginPath();
            ctx.moveTo(screenX + this.width - 8, legY);
            ctx.lineTo(screenX + this.width + 12, legY + 15 - legOffset);
            ctx.lineTo(screenX + this.width + 8, legY + 30 - legOffset);
            ctx.stroke();
        }
        
        // Giant spear weapon
        ctx.fillStyle = '#1a1a1a';
        ctx.fillRect(screenX + (this.facing > 0 ? 58 : -18), screenY + 5, 12, 80);
        ctx.fillStyle = Colors.lava;
        ctx.fillRect(screenX + (this.facing > 0 ? 56 : -16), screenY + 3, 16, 12);
        
        // Phase indicator particles
        if (this.bossPhase >= 2 && Math.random() < 0.1) {
            spawnParticles(
                this.x + Math.random() * this.width,
                this.y + this.height,
                1, Colors.lava, 50, 3, 0.5, -100
            );
        }
    }
}

// ==================== RACER (for level 3) ====================
class Racer {
    constructor(x, y, speed) {
        this.x = x;
        this.y = y;
        this.width = 32;
        this.height = 48;
        this.vx = 0;
        this.vy = 0;
        this.baseSpeed = speed;
        this.speed = speed;
        this.jumpForce = -450;
        this.gravity = 1200;
        this.grounded = false;
        this.finished = false;
        this.animFrame = 0;
        this.animTimer = 0;
        this.jumpCooldown = 0;
    }

    update(dt, platforms, hazards) {
        if (this.finished) return;
        
        this.jumpCooldown -= dt;
        
        // Always move right
        this.vx = this.speed;
        
        // AI jumping logic
        let shouldJump = false;
        
        // Check for gaps ahead (look 50 pixels ahead)
        const groundCheckX = this.x + this.width + 50;
        let hasGroundAhead = false;
        for (const p of platforms) {
            // Check if there's a platform at groundCheckX, at our feet level
            if (groundCheckX >= p.x && groundCheckX <= p.x + p.width &&
                this.y + this.height >= p.y && this.y + this.height <= p.y + p.height + 20) {
                hasGroundAhead = true;
                break;
            }
        }
        if (!hasGroundAhead && this.grounded) shouldJump = true;
        
        // Check for hazards/spikes ahead (simplified)
        for (const h of hazards) {
            if (h.x > this.x && h.x < this.x + 80 && 
                h.y > this.y - 50 && h.y < this.y + 50) {
                shouldJump = true;
                break;
            }
        }
        
        // Check for platforms above to jump to
        for (const p of platforms) {
            if (p.x > this.x && p.x < this.x + 100 && p.y < this.y - 30 && p.y > this.y - 200) {
                shouldJump = true;
                break;
            }
        }
        
        if (shouldJump && this.grounded && this.jumpCooldown <= 0) {
            this.vy = this.jumpForce;
            this.grounded = false;
            this.jumpCooldown = 0.5;
        }
        
        // Gravity
        this.vy += this.gravity * dt;
        if (this.vy > 800) this.vy = 800;
        
        // Movement
        this.x += this.vx * dt;
        this.y += this.vy * dt;
        
        // Platform collision
        this.grounded = false;
        for (const p of platforms) {
            if (this.collides(p)) {
                if (this.vy > 0) {
                    // Landing on top
                    if (this.y + this.height - this.vy * dt <= p.y + 10) {
                        this.y = p.y - this.height;
                        this.vy = 0;
                        this.grounded = true;
                    }
                } else if (this.vy < 0) {
                    // Hitting head on bottom
                    this.y = p.y + p.height;
                    this.vy = 0;
                }
            }
        }
        
        // Safety: if stuck or fell off world, respawn at start
        if (this.y > 1200 || this.x < 0) {
            this.x = 50;
            this.y = 400;
            this.vy = 0;
        }
        
        // Animation
        this.animTimer += dt;
        if (this.animTimer > 0.08) {
            this.animTimer = 0;
            this.animFrame = (this.animFrame + 1) % 4;
        }
    }

    collides(other) {
        return this.x < other.x + other.width &&
               this.x + this.width > other.x &&
               this.y < other.y + other.height &&
               this.y + this.height > other.y;
    }

    draw(ctx, cam) {
        if (this.finished) return;
        
        const screenX = this.x - cam.x;
        const screenY = this.y - cam.y;
        
        // Racer ant
        const bodyColor = '#3a1a1a';
        const segmentColor = '#2a0a0a';
        
        // Head
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(screenX + this.width/2, screenY + 8, 8, 6, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Body segments
        ctx.fillStyle = segmentColor;
        ctx.beginPath();
        ctx.ellipse(screenX + this.width/2, screenY + 16, 6, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(screenX + this.width/2, screenY + 24, 10, 8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Simple legs
        ctx.strokeStyle = bodyColor;
        ctx.lineWidth = 2;
        
        const legOffset = Math.sin(this.animFrame * Math.PI / 2) * 4;
        
        // Left legs
        for (let i = 0; i < 3; i++) {
            const legY = screenY + 10 + i * 6;
            ctx.beginPath();
            ctx.moveTo(screenX + 4, legY);
            ctx.lineTo(screenX - 2, legY + 6 + legOffset);
            ctx.stroke();
        }
        
        // Right legs
        for (let i = 0; i < 3; i++) {
            const legY = screenY + 10 + i * 6;
            ctx.beginPath();
            ctx.moveTo(screenX + this.width - 4, legY);
            ctx.lineTo(screenX + this.width + 2, legY + 6 - legOffset);
            ctx.stroke();
        }
        
        // Antennae
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(screenX + this.width/2 - 2, screenY + 4);
        ctx.lineTo(screenX + this.width/2 - 4, screenY - 2);
        ctx.moveTo(screenX + this.width/2 + 2, screenY + 4);
        ctx.lineTo(screenX + this.width/2 + 4, screenY - 2);
        ctx.stroke();
    }
}

// ==================== INTERACTABLE ====================
class Interactable {
    constructor(x, y, width, height, type, data = {}) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.type = type;
        this.data = data;
        this.activated = false;
        this.animTimer = 0;
    }

    update(dt, player) {
        this.animTimer += dt;
        
        // Special handling for pressure plates - automatic activation on collision
        if (this.type === 'pressurePlate') {
            const isSteppingOn = player.x < this.x + this.width &&
                                player.x + player.width > this.x &&
                                player.y < this.y + this.height &&
                                player.y + player.height > this.y;
            
            if (isSteppingOn && !this.activated) {
                this.activated = true;
                if (this.data.onActivate) this.data.onActivate();
                spawnParticles(this.x + this.width/2, this.y, 8, Colors.gold, 60, 2, 0.5, -20);
            } else if (!isSteppingOn && this.activated) {
                this.activated = false;
            }
            return;
        }
        
        // Special handling for crystals - automatic collection
        if (this.type === 'crystal') {
            if (!this.activated) {
                const isNearby = player.x < this.x + this.width + 20 &&
                                player.x + player.width > this.x - 20 &&
                                player.y < this.y + this.height + 20 &&
                                player.y + player.height > this.y - 20;
                
                if (isNearby) {
                    this.activated = true;
                    player.canDoubleJump = true;
                    if (this.data.onActivate) this.data.onActivate();
                    spawnParticles(this.x + this.width/2, this.y + this.height/2, 20, Colors.crystal, 100, 4, 1, 0);
                }
            }
            return;
        }
        
        // Regular interactable handling
        const inRange = Math.abs(player.x - this.x) < 50 && Math.abs(player.y - this.y) < 50;
        
        if (inRange && keys['KeyE'] && !this.activated) {
            this.interact(player);
        }
    }

    interact(player) {
        switch (this.type) {
            case 'riddle':
            case 'mathPuzzle':
            case 'wordPuzzle':
            case 'logicPuzzle':
            case 'finalRiddle':
                if (!this.data.solved && this.data.onActivate) {
                    this.data.onActivate();
                }
                break;
            case 'weakPoint':
                if (this.activated && player.attacking) {
                    // Hit weak point for massive damage
                    const boss = enemies.find(e => e.type === 'boss');
                    if (boss) {
                        boss.takeDamage(50); // Critical hit damage
                        this.activated = false;
                        spawnParticles(this.x + this.width/2, this.y + this.height/2, 20, Colors.gold, 150, 6, 2, 0);
                    }
                }
                break;
            case 'crystalSwitch':
                if (!this.activated && this.data.onActivate) {
                    this.data.onActivate();
                    spawnParticles(this.x + this.width/2, this.y + this.height/2, 15, 
                        this.data.color === 'red' ? '#ff4444' : 
                        this.data.color === 'blue' ? '#4444ff' : 
                        this.data.color === 'green' ? '#44ff44' : '#ff44ff', 
                        100, 4, 1, 0);
                }
                break;
            case 'lever':
                this.activated = !this.activated;
                if (this.data.onActivate) this.data.onActivate(this.activated);
                spawnParticles(this.x + this.width/2, this.y, 10, Colors.gold, 80, 3, 0.5, -50);
                break;
            case 'health':
                if (!this.activated) {
                    this.activated = true;
                    player.heal(50);
                }
                break;
            case 'checkpoint':
                this.activated = true;
                currentCheckpoint = { x: this.x, y: this.y - 50 };
                spawnParticles(this.x + this.width/2, this.y, 15, Colors.gold, 60, 3, 0.8, -30);
                break;
            case 'platform':
                // Platforms are handled in update, not interact
                break;
        }
    }

    draw(ctx, cam) {
        const screenX = this.x - cam.x;
        const screenY = this.y - cam.y;
        
        switch (this.type) {
            case 'riddle':
            case 'mathPuzzle':
            case 'wordPuzzle':
            case 'logicPuzzle':
            case 'finalRiddle':
                // Draw puzzle terminal/scroll
                ctx.fillStyle = '#2a2a2a';
                ctx.fillRect(screenX, screenY, this.width, this.height);
                
                // Border
                ctx.strokeStyle = this.data.solved ? '#00ff00' : '#ffaa00';
                ctx.lineWidth = 2;
                ctx.strokeRect(screenX, screenY, this.width, this.height);
                
                // Question mark or checkmark
                ctx.fillStyle = this.data.solved ? '#00ff00' : '#ffaa00';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(this.data.solved ? '‚úì' : '?', screenX + this.width/2, screenY + this.height/2 + 5);
                
                // Glow effect when active
                if (!this.data.solved) {
                    ctx.fillStyle = `rgba(255, 170, 0, ${0.3 + Math.sin(this.animTimer * 3) * 0.2})`;
                    ctx.fillRect(screenX - 5, screenY - 5, this.width + 10, this.height + 10);
                }
                break;
            case 'platform':
                if (this.visible) {
                    const colors = {
                        red: '#ff4444',
                        blue: '#4444ff', 
                        green: '#44ff44'
                    };
                    const color = colors[this.data.color] || '#ffffff';
                    
                    // Draw glowing platform
                    ctx.fillStyle = `${color}88`;
                    ctx.fillRect(screenX, screenY, this.width, this.height);
                    
                    // Add glow effect
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 10;
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenX, screenY, this.width, this.height);
                    ctx.shadowBlur = 0;
                }
                break;
            case 'weakPoint':
                if (this.activated) {
                    // Glowing weak point
                    ctx.fillStyle = `rgba(255, 215, 0, ${0.5 + Math.sin(this.animTimer * 8) * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(screenX + this.width/2, screenY + this.height/2, 20, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Inner core
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(screenX + this.width/2, screenY + this.height/2, 8, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Hidden weak point
                    ctx.fillStyle = 'rgba(100, 100, 100, 0.3)';
                    ctx.fillRect(screenX, screenY, this.width, this.height);
                }
                break;
            case 'crystalSwitch':
                if (this.activated) return;
                
                // Draw crystal with color
                const colors = {
                    red: '#ff4444',
                    blue: '#4444ff', 
                    green: '#44ff44'
                };
                const color = colors[this.data.color] || '#ffffff';
                
                // Glow effect
                ctx.fillStyle = `${color}33`;
                ctx.beginPath();
                ctx.arc(screenX + this.width/2, screenY + this.height/2, 25, 0, Math.PI * 2);
                ctx.fill();
                
                // Crystal
                ctx.fillStyle = this.activated ? color : `${color}88`;
                ctx.beginPath();
                ctx.moveTo(screenX + this.width/2, screenY);
                ctx.lineTo(screenX + this.width, screenY + this.height * 0.7);
                ctx.lineTo(screenX + this.width/2, screenY + this.height);
                ctx.lineTo(screenX, screenY + this.height * 0.7);
                ctx.closePath();
                ctx.fill();
                
                // Inner light
                if (this.activated) {
                    ctx.fillStyle = `${color}ff`;
                    ctx.beginPath();
                    ctx.arc(screenX + this.width/2, screenY + this.height/2, 5, 0, Math.PI * 2);
                    ctx.fill();
                }
                break;
            case 'lever':
                // Base
                ctx.fillStyle = Colors.rock;
                ctx.fillRect(screenX, screenY + 20, 20, 20);
                // Handle
                ctx.fillStyle = this.activated ? Colors.gold : '#666';
                ctx.save();
                ctx.translate(screenX + 10, screenY + 20);
                ctx.rotate(this.activated ? 0.5 : -0.5);
                ctx.fillRect(-3, -25, 6, 25);
                ctx.restore();
                break;
                
            case 'crystal':
                if (this.activated) return;
                // Glow
                ctx.fillStyle = `rgba(0, 255, 255, ${0.2 + Math.sin(this.animTimer * 3) * 0.1})`;
                ctx.beginPath();
                ctx.arc(screenX + this.width/2, screenY + this.height/2, 30, 0, Math.PI * 2);
                ctx.fill();
                // Crystal shape
                ctx.fillStyle = Colors.crystal;
                ctx.beginPath();
                ctx.moveTo(screenX + this.width/2, screenY);
                ctx.lineTo(screenX + this.width, screenY + this.height * 0.7);
                ctx.lineTo(screenX + this.width/2, screenY + this.height);
                ctx.lineTo(screenX, screenY + this.height * 0.7);
                ctx.closePath();
                ctx.fill();
                break;
                
            case 'health':
                if (this.activated) return;
                ctx.fillStyle = '#00ff00';
                ctx.fillRect(screenX + 8, screenY, 8, 24);
                ctx.fillRect(screenX, screenY + 8, 24, 8);
                break;
                
            case 'checkpoint':
                // Flag pole
                ctx.fillStyle = this.activated ? Colors.gold : '#666';
                ctx.fillRect(screenX + 10, screenY, 4, 50);
                // Flag
                ctx.fillStyle = this.activated ? Colors.gold : '#888';
                ctx.beginPath();
                ctx.moveTo(screenX + 14, screenY);
                ctx.lineTo(screenX + 34, screenY + 10);
                ctx.lineTo(screenX + 14, screenY + 20);
                ctx.closePath();
                ctx.fill();
                break;
                
            case 'door':
                ctx.fillStyle = this.activated ? Colors.caveDark : '#4a3a2a';
                ctx.fillRect(screenX, screenY, this.width, this.height);
                if (!this.activated) {
                    ctx.fillStyle = Colors.gold;
                    ctx.fillRect(screenX + this.width - 8, screenY + this.height/2 - 4, 6, 8);
                }
                break;
                
            case 'pressurePlate':
                ctx.fillStyle = this.activated ? Colors.gold : Colors.rock;
                ctx.fillRect(screenX, screenY + (this.activated ? 5 : 0), this.width, 10);
                break;
        }
    }
}

// ==================== LEVEL DATA ====================
let player;
let platforms = [];
let hazards = [];
let enemies = [];
let interactables = [];
let racers = [];
let levelWidth = 0;
let levelHeight = 0;
let currentCheckpoint = null;
let levelGoal = null;
let raceTimer = 0;
let puzzlesSolved = 0;
let puzzlesRequired = 0;

function createLevel(levelNum) {
    platforms = [];
    hazards = [];
    enemies = [];
    interactables = [];
    racers = [];
    particles.length = 0;
    puzzlesSolved = 0;
    
    switch (levelNum) {
        case 1:
            createLevel1();
            break;
        case 2:
            createLevel2();
            break;
        case 3:
            createLevel3();
            break;
        case 4:
            createBossFight();
            break;
    }
}

function createLevel1() {
    // Episode 1: The Descent - Harder but double-jumpable
    levelWidth = 3000;
    levelHeight = 800;
    
    player = new Player(100, 300);
    currentCheckpoint = { x: 100, y: 300 };
    levelGoal = { x: 2800, y: 300, width: 50, height: 100 };
    
    // Starting platform
    addPlatform(0, 400, 150, 50);
    
    // Challenging jump sequence - requires double jump
    addPlatform(200, 350, 80, 20);
    addPlatform(350, 300, 60, 20);
    addPlatform(480, 250, 50, 20);
    addPlatform(600, 200, 40, 20);
    
    // Double jump challenge
    addPlatform(700, 250, 60, 20);
    addPlatform(850, 300, 50, 20);
    addPlatform(980, 350, 40, 20);
    
    // Checkpoint after first challenge
    interactables.push(new Interactable(950, 300, 24, 50, 'checkpoint'));
    
    // Vertical climbing section
    addPlatform(1100, 400, 100, 20);
    addPlatform(1050, 320, 60, 20);
    addPlatform(1000, 240, 50, 20);
    addPlatform(950, 160, 40, 20);
    
    // Gap jumping section - requires precise double jumps
    addPlatform(1150, 200, 50, 20);
    addPlatform(1300, 250, 40, 20);
    addPlatform(1450, 300, 35, 20);
    addPlatform(1600, 350, 30, 20);
    
    // Spike pit challenge
    addPlatform(1750, 400, 200, 50);
    addHazard(1780, 380, 140, 20, 'spikes');
    
    // Floating platforms over spikes - double jump required
    addPlatform(1800, 320, 40, 15);
    addPlatform(1880, 280, 35, 15);
    addPlatform(1950, 320, 40, 15);
    
    // Crystal power-up - harder to reach
    interactables.push(new Interactable(1880, 230, 24, 40, 'crystal'));
    
    // Moving platform section simulation
    addPlatform(2050, 400, 60, 20);
    addPlatform(2200, 350, 50, 20);
    addPlatform(2350, 300, 40, 20);
    addPlatform(2500, 250, 35, 20);
    
    // Checkpoint before final challenge
    interactables.push(new Interactable(2300, 250, 24, 50, 'checkpoint'));
    
    // Final challenging section
    addPlatform(2650, 350, 80, 20);
    addPlatform(2800, 400, 200, 50);
    
    // More enemies for increased difficulty
    enemies.push(new Enemy(300, 250, 'soldier'));
    enemies.push(new Enemy(600, 150, 'soldier'));
    enemies.push(new Enemy(950, 300, 'soldier'));
    enemies.push(new Enemy(1300, 200, 'soldier'));
    enemies.push(new Enemy(1800, 350, 'soldier'));
    enemies.push(new Enemy(2300, 200, 'soldier'));
    
    // Health pickups in strategic locations
    interactables.push(new Interactable(480, 200, 24, 24, 'health'));
    interactables.push(new Interactable(950, 110, 24, 24, 'health'));
    interactables.push(new Interactable(1950, 270, 24, 24, 'health'));
    interactables.push(new Interactable(2500, 200, 24, 24, 'health'));
    
    // Additional hazards
    addPlatform(1200, 500, 100, 50);
    addHazard(1220, 480, 60, 20, 'spikes');
    
    addPlatform(2100, 500, 150, 50);
    addHazard(2130, 480, 90, 20, 'spikes');
}

function createLevel2() {
    // Episode 2: The Crystal Riddles - Verbal puzzles only
    levelWidth = 1400;
    levelHeight = 600;
    puzzlesRequired = 4;
    puzzlesSolved = 0; // Reset puzzle progress
    
    player = new Player(100, 400);
    currentCheckpoint = { x: 100, y: 400 };
    
    // Main floor platform
    addPlatform(0, 500, 1400, 100);
    
    // Puzzle 1: Riddle Door
    const riddle1 = new Interactable(200, 460, 60, 40, 'riddle', {
        question: "I have cities, but no houses live there. I have mountains, but no trees. I have water, but no fish. What am I?",
        answer: "map",
        solved: false
    });
    const door1 = new Interactable(400, 400, 50, 100, 'door');
    
    riddle1.data.onActivate = () => {
        const answer = prompt(riddle1.data.question);
        if (answer && answer.toLowerCase().trim() === riddle1.data.answer) {
            riddle1.data.solved = true;
            door1.activated = true;
            puzzlesSolved++;
            updatePuzzleUI();
            spawnParticles(425, 350, 20, Colors.gold, 100, 5, 1, -50);
        } else {
            spawnParticles(230, 480, 10, Colors.spike, 80, 3, 0.5, 100);
        }
    };
    
    interactables.push(riddle1, door1);
    
    // Puzzle 2: Fun Math Puzzle
    const mathPuzzle = new Interactable(600, 460, 60, 40, 'mathPuzzle', {
        question: "If 3 ants can carry 3 crumbs in 3 minutes, how many ants are needed to carry 100 crumbs in 100 minutes?",
        answer: "3",
        hint: "Think about the rate - it's a trick question!",
        solved: false
    });
    const door2 = new Interactable(800, 400, 50, 100, 'door');
    
    mathPuzzle.data.onActivate = () => {
        const answer = prompt(mathPuzzle.data.question + "\n\nHint: " + mathPuzzle.data.hint);
        if (answer && answer.toLowerCase().trim() === mathPuzzle.data.answer) {
            mathPuzzle.data.solved = true;
            door2.activated = true;
            puzzlesSolved++;
            updatePuzzleUI();
            spawnParticles(825, 350, 20, Colors.gold, 100, 5, 1, -50);
        } else {
            spawnParticles(630, 480, 10, Colors.spike, 80, 3, 0.5, 100);
        }
    };
    
    interactables.push(mathPuzzle, door2);
    
    // Checkpoint
    interactables.push(new Interactable(500, 450, 24, 50, 'checkpoint'));
    
    // Puzzle 3: Logic Puzzle
    const logicPuzzle = new Interactable(1000, 460, 60, 40, 'logicPuzzle', {
        question: "Three ants are walking in a line. The first ant says 'All of us are liars.' The second ant says nothing. The third ant says 'The first ant is telling the truth.' Who is telling the truth?",
        answer: "none",
        hint: "Think about paradoxes",
        solved: false
    });
    const door3 = new Interactable(1200, 400, 50, 100, 'door');
    
    logicPuzzle.data.onActivate = () => {
        const answer = prompt(logicPuzzle.data.question + "\n\nHint: " + logicPuzzle.data.hint);
        if (answer && answer.toLowerCase().trim() === logicPuzzle.data.answer) {
            logicPuzzle.data.solved = true;
            door3.activated = true;
            puzzlesSolved++;
            updatePuzzleUI();
            spawnParticles(1225, 350, 20, Colors.gold, 100, 5, 1, -50);
        } else {
            spawnParticles(1030, 480, 10, Colors.spike, 80, 3, 0.5, 100);
        }
    };
    
    interactables.push(logicPuzzle, door3);
    
    // Puzzle 4: Final Riddle
    const finalRiddle = new Interactable(1300, 460, 60, 40, 'finalRiddle', {
        question: "I am the beginning of eternity, the end of time and space. I am the beginning of every end, and the end of every place. What am I?",
        answer: "e",
        hint: "Look for a single letter",
        solved: false
    });
    const finalDoor = new Interactable(1350, 400, 50, 100, 'door');
    
    finalRiddle.data.onActivate = () => {
        if (puzzlesSolved >= 3) {
            const answer = prompt(finalRiddle.data.question + "\n\nHint: " + finalRiddle.data.hint);
            if (answer && answer.toLowerCase().trim() === finalRiddle.data.answer) {
                finalRiddle.data.solved = true;
                finalDoor.activated = true;
                puzzlesSolved++;
                updatePuzzleUI();
                spawnParticles(1375, 350, 30, Colors.gold, 150, 8, 2, -50);
            } else {
                spawnParticles(1330, 480, 10, Colors.spike, 80, 3, 0.5, 100);
            }
        } else {
            spawnParticles(1330, 480, 10, Colors.spike, 80, 3, 0.5, 100);
        }
    };
    
    interactables.push(finalRiddle, finalDoor);
    
    // Health pickups
    interactables.push(new Interactable(300, 430, 24, 24, 'health'));
    interactables.push(new Interactable(700, 430, 24, 24, 'health'));
    interactables.push(new Interactable(1100, 430, 24, 24, 'health'));
    
    // Exit
    levelGoal = { x: 1350, y: 400, width: 50, height: 100 };
    
    // Decorative elements
    interactables.push(new Interactable(50, 470, 20, 30, 'crystalSwitch', { color: 'purple', activated: true }));
    
    updatePuzzleHint();
}

function createLevel3() {
    // Episode 3: The Combat Race - Race to finish with combat
    levelWidth = 2500;
    levelHeight = 600;
    raceTimer = 0;
    
    player = new Player(50, 400);
    levelGoal = { x: 2400, y: 300, width: 100, height: 200 };
    
    // Create combat racers with AI
    racers.push(new Racer(50, 400, 160));
    racers.push(new Racer(50, 400, 140));
    
    // Combat race track with enemy encounters
    // Starting area
    addPlatform(0, 500, 400, 50);
    
    // First combat zone
    addPlatform(450, 500, 200, 50);
    enemies.push(new Enemy(500, 450, 'soldier'));
    enemies.push(new Enemy(550, 450, 'soldier'));
    
    // Jump to next zone
    addPlatform(700, 450, 150, 50);
    addPlatform(900, 400, 150, 50);
    
    // Second combat zone
    addPlatform(1100, 500, 300, 50);
    enemies.push(new Enemy(1150, 450, 'soldier'));
    enemies.push(new Enemy(1250, 450, 'soldier'));
    enemies.push(new Enemy(1200, 450, 'soldier'));
    
    // Health pickup after combat
    interactables.push(new Interactable(1200, 430, 24, 24, 'health'));
    
    // Vertical section with enemies
    addPlatform(1450, 500, 100, 50);
    addPlatform(1400, 400, 80, 20);
    addPlatform(1350, 300, 80, 20);
    enemies.push(new Enemy(1400, 350, 'soldier'));
    
    // Crystal power-up for double jump advantage
    interactables.push(new Interactable(1350, 250, 24, 40, 'crystal'));
    
    // Third combat zone - boss area
    addPlatform(1600, 500, 400, 50);
    enemies.push(new Enemy(1700, 450, 'soldier'));
    enemies.push(new Enemy(1800, 450, 'soldier'));
    enemies.push(new Enemy(1750, 450, 'soldier'));
    enemies.push(new Enemy(1850, 450, 'soldier'));
    
    // More health pickups
    interactables.push(new Interactable(1750, 430, 24, 24, 'health'));
    interactables.push(new Interactable(1850, 430, 24, 24, 'health'));
    
    // Final sprint with obstacles
    addPlatform(2050, 500, 150, 50);
    addHazard(2100, 480, 50, 20, 'spikes');
    
    addPlatform(2250, 500, 150, 50);
    addHazard(2300, 480, 50, 20, 'spikes');
    
    // Final stretch
    addPlatform(2450, 500, 50, 50);
    
    // Checkpoint for player
    interactables.push(new Interactable(1200, 450, 24, 50, 'checkpoint'));
    
    // Combat race UIÊèêÁ§∫
    updatePuzzleHint();
}

function createBossFight() {
    // Boss Fight: Fixed Mario-style boss battle
    levelWidth = 1200;
    levelHeight = 600;
    
    // Enhanced player health for boss battle
    player = new Player(100, 400);
    player.health = 150;
    player.maxHealth = 150;
    currentCheckpoint = { x: 100, y: 400 };
    
    // Arena with platforms
    addPlatform(0, 500, 1200, 100);
    
    // Platforms for jumping
    addPlatform(200, 400, 100, 20);
    addPlatform(500, 350, 100, 20);
    addPlatform(800, 400, 100, 20);
    
    // Side walls
    addPlatform(0, 200, 50, 300);
    addPlatform(1150, 200, 50, 300);
    
    // Health pickups
    interactables.push(new Interactable(230, 350, 24, 24, 'health'));
    interactables.push(new Interactable(530, 300, 24, 24, 'health'));
    interactables.push(new Interactable(830, 350, 24, 24, 'health'));
    interactables.push(new Interactable(350, 450, 24, 24, 'health'));
    interactables.push(new Interactable(650, 450, 24, 24, 'health'));
    
    // FIXED BOSS - doesn't move, just attacks
    const boss = new Enemy(700, 300, 'boss');
    boss.health = 1000;
    boss.maxHealth = 1000;
    boss.x = 700; // Fixed position
    boss.y = 300; // Fixed position
    boss.vx = 0;  // No movement
    boss.fixed = true; // Flag for fixed boss
    boss.attackTimer = 0;
    boss.specialAttackTimer = 0;
    boss.bossPhase = 1;
    enemies.push(boss);
    
    // Boss UI
    document.getElementById('bossHealth').style.display = 'block';
    document.getElementById('bossHealthFill').style.width = '100%';
    
    // Update player health display
    document.getElementById('healthFill').style.width = '100%';
}

function spawnBossAttackIndicators() {
    // Visual warnings for boss attacks
    const warningIndicator = {
        x: 0, y: 0, width: 50, height: 50,
        type: 'warning',
        timer: 0,
        pattern: null
    };
    // Will be used in boss AI for attack telegraphs
}

function addPlatform(x, y, w, h) {
    platforms.push({ x, y, width: w, height: h, type: 'solid' });
}

function addHazard(x, y, w, h, type) {
    hazards.push({ x, y, width: w, height: h, type, damage: 20 });
}

function updatePuzzleUI() {
    if (currentLevel === 2) {
        document.getElementById('puzzleHint').textContent = 
            `Puzzles Solved: ${puzzlesSolved} / ${puzzlesRequired}`;
        updatePuzzleHint();
    }
}

function updatePuzzleHint() {
    if (currentLevel === 2) {
        const hints = [
            "Find the crystal sequence: Red ‚Üí Blue ‚Üí Green",
            "Activate all pressure plates to proceed",
            "Use the timed lever quickly before the door closes!"
        ];
        const currentHint = hints[Math.min(puzzlesSolved, hints.length - 1)];
        document.getElementById('puzzleHint').textContent = currentHint;
    }
}

// ==================== DRAWING ====================
function drawBackground(ctx) {
    // Underground gradient background
    const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
    gradient.addColorStop(0, '#050505');
    gradient.addColorStop(0.3, '#0a0a0f');
    gradient.addColorStop(0.7, '#1a1510');
    gradient.addColorStop(1, '#2a2015');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Underground layers
    drawUndergroundLayer(ctx, 0.2, Colors.soilDark);
    drawUndergroundLayer(ctx, 0.4, Colors.soil);
    drawUndergroundLayer(ctx, 0.6, Colors.dirtDark);
    
    // Add some roots hanging down
    drawRoots(ctx, camera);
    
    // Add fungi clusters
    drawFungi(ctx, camera);
}

function drawUndergroundLayer(ctx, parallax, color) {
    ctx.fillStyle = color;
    const offset = -camera.x * parallax;
    
    for (let i = 0; i < 25; i++) {
        const x = (i * 180 + offset) % (canvas.width + 360) - 180;
        const y = canvas.height - 80 - Math.sin(i * 0.4) * 60;
        
        // Soil/rock formations
        ctx.beginPath();
        ctx.moveTo(x - 20, 0);
        ctx.lineTo(x + 10, y + Math.sin(i * 0.8) * 40);
        ctx.lineTo(x + 40, 0);
        ctx.fill();
        
        // Ground irregularities
        ctx.beginPath();
        ctx.moveTo(x + 80, canvas.height);
        ctx.lineTo(x + 100, y - Math.sin(i * 0.6) * 30);
        ctx.lineTo(x + 120, canvas.height);
        ctx.fill();
    }
}

function drawRoots(ctx, cam) {
    ctx.strokeStyle = Colors.roots;
    ctx.lineWidth = 3;
    
    for (let i = 0; i < 8; i++) {
        const rootX = (i * 200 - cam.x * 0.3) % (canvas.width + 400) - 200;
        const rootY = Math.sin(i * 1.5) * 50;
        
        ctx.beginPath();
        ctx.moveTo(rootX, rootY);
        
        // Wavy root pattern
        for (let j = 0; j < 5; j++) {
            const y = rootY + j * 40;
            const x = rootX + Math.sin(j * 0.8 + i) * 20;
            ctx.lineTo(x, y);
        }
        
        ctx.stroke();
    }
}

function drawFungi(ctx, cam) {
    for (let i = 0; i < 6; i++) {
        const fungiX = (i * 250 - cam.x * 0.5) % (canvas.width + 500) - 250;
        const fungiY = canvas.height - 120 + Math.sin(i * 2) * 30;
        
        // Mushroom stalk
        ctx.fillStyle = Colors.fungi;
        ctx.fillRect(fungiX, fungiY, 8, 20);
        
        // Mushroom cap
        ctx.fillStyle = Colors.moss;
        ctx.beginPath();
        ctx.arc(fungiX + 4, fungiY, 12, Math.PI, 0);
        ctx.fill();
        
        // Small spots
        ctx.fillStyle = Colors.soilLight;
        ctx.beginPath();
        ctx.arc(fungiX + 2, fungiY - 3, 2, 0, Math.PI * 2);
        ctx.arc(fungiX + 6, fungiY - 5, 1, 0, Math.PI * 2);
        ctx.fill();
    }
}

function drawPlatforms(ctx, cam) {
    for (const p of platforms) {
        const screenX = p.x - cam.x;
        const screenY = p.y - cam.y;
        
        // Main platform with dirt/soil texture
        const gradient = ctx.createLinearGradient(screenX, screenY, screenX, screenY + p.height);
        gradient.addColorStop(0, Colors.dirtLight);
        gradient.addColorStop(0.3, Colors.dirt);
        gradient.addColorStop(0.7, Colors.soil);
        gradient.addColorStop(1, Colors.soilDark);
        ctx.fillStyle = gradient;
        ctx.fillRect(screenX, screenY, p.width, p.height);
        
        // Stone/rock overlay on top
        ctx.fillStyle = Colors.stone;
        ctx.fillRect(screenX, screenY, p.width, 6);
        
        // Soil texture patches
        ctx.fillStyle = Colors.soilLight;
        for (let i = 0; i < p.width; i += 25) {
            if (Math.random() > 0.3) {
                ctx.fillRect(screenX + i + 8, screenY + 10, 12, 4);
            }
        }
        
        // Clay deposits
        ctx.fillStyle = Colors.clay;
        for (let i = 0; i < p.width; i += 40) {
            if (Math.random() > 0.5) {
                ctx.fillRect(screenX + i + 15, screenY + 15, 8, 8);
            }
        }
        
        // Stone pebbles
        ctx.fillStyle = Colors.stoneDark;
        for (let i = 0; i < p.width; i += 30) {
            ctx.beginPath();
            ctx.arc(screenX + i + 10, screenY + p.height - 8, 3, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Bottom shadow
        ctx.fillStyle = 'rgba(0,0,0,0.4)';
        ctx.fillRect(screenX, screenY + p.height - 6, p.width, 6);
        
        // Moss patches on edges
        if (Math.random() > 0.6) {
            ctx.fillStyle = Colors.moss;
            ctx.fillRect(screenX, screenY, p.width, 2);
        }
    }
}

function drawHazards(ctx, cam) {
    for (const h of hazards) {
        const screenX = h.x - cam.x;
        const screenY = h.y - cam.y;
        
        if (h.type === 'spikes') {
            ctx.fillStyle = Colors.spike;
            const spikeWidth = 15;
            const spikeCount = Math.floor(h.width / spikeWidth);
            
            for (let i = 0; i < spikeCount; i++) {
                ctx.beginPath();
                ctx.moveTo(screenX + i * spikeWidth, screenY + h.height);
                ctx.lineTo(screenX + i * spikeWidth + spikeWidth/2, screenY);
                ctx.lineTo(screenX + (i + 1) * spikeWidth, screenY + h.height);
                ctx.closePath();
                ctx.fill();
            }
            
            // Glow effect
            ctx.fillStyle = 'rgba(139, 0, 0, 0.3)';
            ctx.fillRect(screenX - 5, screenY - 5, h.width + 10, h.height + 10);
        } else if (h.type === 'lava') {
            // Animated lava
            ctx.fillStyle = Colors.lava;
            ctx.fillRect(screenX, screenY, h.width, h.height);
            
            // Bubbles
            ctx.fillStyle = Colors.lavaGlow;
            for (let i = 0; i < 5; i++) {
                const bx = screenX + (Math.sin(gameTime * 2 + i) * 0.5 + 0.5) * h.width;
                const by = screenY + Math.abs(Math.sin(gameTime * 3 + i * 2)) * h.height * 0.5;
                ctx.beginPath();
                ctx.arc(bx, by, 4, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
}

function drawGoal(ctx, cam) {
    if (!levelGoal) return;
    
    const screenX = levelGoal.x - cam.x;
    const screenY = levelGoal.y - cam.y;
    
    // Glowing portal effect
    ctx.fillStyle = `rgba(255, 215, 0, ${0.3 + Math.sin(gameTime * 3) * 0.1})`;
    ctx.beginPath();
    ctx.ellipse(screenX + levelGoal.width/2, screenY + levelGoal.height/2, 
                levelGoal.width, levelGoal.height/2, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Inner glow
    ctx.fillStyle = `rgba(255, 255, 200, ${0.5 + Math.sin(gameTime * 4) * 0.2})`;
    ctx.beginPath();
    ctx.ellipse(screenX + levelGoal.width/2, screenY + levelGoal.height/2, 
                levelGoal.width * 0.6, levelGoal.height * 0.3, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Particles
    if (Math.random() < 0.2) {
        spawnParticles(
            levelGoal.x + Math.random() * levelGoal.width,
            levelGoal.y + levelGoal.height,
            1, Colors.gold, 30, 2, 1, -50
        );
    }
}

function drawTorchLight(ctx, x, y, radius) {
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
    gradient.addColorStop(0, 'rgba(255, 150, 50, 0.4)');
    gradient.addColorStop(0.5, 'rgba(255, 100, 30, 0.2)');
    gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.fill();
}

function drawAmbientLighting(ctx, cam) {
    // Bioluminescent fungi lights
    const fungiSpacing = 350;
    const startX = Math.floor(cam.x / fungiSpacing) * fungiSpacing;
    
    for (let x = startX; x < cam.x + canvas.width + fungiSpacing; x += fungiSpacing) {
        const screenX = x - cam.x;
        const flicker = Math.sin(gameTime * 8 + x * 0.01) * 15;
        // Greenish bioluminescent light
        const gradient = ctx.createRadialGradient(screenX, canvas.height - 150, 0, screenX, canvas.height - 150, 100 + flicker);
        gradient.addColorStop(0, 'rgba(150, 255, 150, 0.3)');
        gradient.addColorStop(0.5, 'rgba(100, 200, 100, 0.15)');
        gradient.addColorStop(1, 'rgba(50, 150, 50, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(screenX, canvas.height - 150, 100 + flicker, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Crystal lights
    const crystalSpacing = 500;
    const crystalStartX = Math.floor(cam.x / crystalSpacing) * crystalSpacing;
    
    for (let x = crystalStartX; x < cam.x + canvas.width + crystalSpacing; x += crystalSpacing) {
        const screenX = x - cam.x;
        const flicker = Math.sin(gameTime * 12 + x * 0.02) * 20;
        // Blue crystal light
        const gradient = ctx.createRadialGradient(screenX, 200, 0, screenX, 200, 80 + flicker);
        gradient.addColorStop(0, 'rgba(0, 255, 255, 0.4)');
        gradient.addColorStop(0.5, 'rgba(0, 200, 255, 0.2)');
        gradient.addColorStop(1, 'rgba(0, 150, 255, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(screenX, 200, 80 + flicker, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Player light (warmer tone)
    const playerScreenX = player.x - cam.x + player.width/2;
    const playerScreenY = player.y - cam.y + player.height/2;
    const gradient = ctx.createRadialGradient(playerScreenX, playerScreenY, 0, playerScreenX, playerScreenY, 120);
    gradient.addColorStop(0, 'rgba(255, 200, 150, 0.6)');
    gradient.addColorStop(0.5, 'rgba(255, 150, 100, 0.3)');
    gradient.addColorStop(1, 'rgba(255, 100, 50, 0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(playerScreenX, playerScreenY, 120, 0, Math.PI * 2);
    ctx.fill();
}

function drawRacePosition(ctx) {
    if (currentLevel !== 3) return;
    
    // Calculate positions
    let positions = [
        { name: 'You', x: player.x, isPlayer: true },
        ...racers.map((r, i) => ({ name: `Enemy ${i+1}`, x: r.x, isPlayer: false }))
    ];
    
    positions.sort((a, b) => b.x - a.x);
    const playerPos = positions.findIndex(p => p.isPlayer) + 1;
    
    const posText = playerPos === 1 ? '1st' : playerPos === 2 ? '2nd' : 
                    playerPos === 3 ? '3rd' : `${playerPos}th`;
    
    document.getElementById('racePosition').textContent = posText;
    document.getElementById('racePosition').style.color = 
        playerPos === 1 ? Colors.gold : playerPos <= 2 ? '#00ff00' : '#ff4444';
}

// ==================== GAME LOOP ====================
function update(dt) {
    gameTime += dt;
    
    if (currentState !== GameState.PLAYING) return;
    
    // Update player
    player.update(dt, platforms, hazards, enemies);
    
    // Camera follow
    camera.follow(player, levelWidth, levelHeight);
    
    // Update enemies
    enemies.forEach(e => e.update(dt, player, platforms));
    
    // Update racers (level 3)
    if (currentLevel === 3) {
        raceTimer += dt;
        racers.forEach(r => {
            if (!r.finished) {
                r.update(dt, platforms, hazards);
                // Check if this racer finished
                if (levelGoal && r.x >= levelGoal.x) {
                    r.finished = true;
                }
            }
        });
        
        // Only check for race loss if player hasn't finished
        if (levelGoal && player.x < levelGoal.x) {
            const allRacersFinished = racers.every(r => r.finished);
            if (allRacersFinished) {
                // Small delay before game over to avoid instant death
                setTimeout(() => {
                    if (currentState === GameState.PLAYING && player.x < levelGoal.x) {
                        gameOver();
                    }
                }, 500);
            }
        }
    }
    
    // Update interactables
    interactables.forEach(i => i.update(dt, player));
    
    // Check goal
    if (levelGoal) {
        if (player.x < levelGoal.x + levelGoal.width &&
            player.x + player.width > levelGoal.x &&
            player.y < levelGoal.y + levelGoal.height &&
            player.y + player.height > levelGoal.y) {
            
            // Level 2 requires puzzles
            if (currentLevel === 2 && puzzlesSolved < puzzlesRequired) {
                // Can't exit yet - show feedback
                spawnParticles(player.x + player.width/2, player.y, 10, Colors.spike, 80, 3, 0.5, 100);
            } else {
                levelComplete();
            }
        }
    }
    
    // Check death by falling
    if (player.y > levelHeight + 100) {
        if (currentCheckpoint) {
            player.x = currentCheckpoint.x;
            player.y = currentCheckpoint.y;
            player.vy = 0;
            player.takeDamage(20);
        } else {
            gameOver();
        }
    }
    
    // Update particles
    updateParticles(dt);
    
    // Update boss spears
    for (const enemy of enemies) {
        if (enemy.spears) {
            for (let i = enemy.spears.length - 1; i >= 0; i--) {
                const spear = enemy.spears[i];
                spear.x += spear.vx * dt;
                spear.y += spear.vy * dt;
                spear.vy += 300 * dt; // Gravity
                spear.lifetime -= dt;
                
                // Check collision with player
                if (player.collidesWith(spear)) {
                    player.takeDamage(spear.damage);
                    enemy.spears.splice(i, 1);
                    spawnParticles(spear.x, spear.y, 10, Colors.stone, 80, 3, 0.5, 0);
                    continue;
                }
                
                // Check collision with platforms
                for (const platform of platforms) {
                    if (spear.x < platform.x + platform.width &&
                        spear.x + spear.width > platform.x &&
                        spear.y < platform.y + platform.height &&
                        spear.y + spear.height > platform.y) {
                        enemy.spears.splice(i, 1);
                        spawnParticles(spear.x, spear.y, 8, Colors.stone, 60, 2, 0.5, 0);
                        break;
                    }
                }
                
                // Remove if lifetime expired
                if (spear.lifetime <= 0) {
                    enemy.spears.splice(i, 1);
                }
            }
        }
    }
    
    // Update player bullets
    if (player.bullets) {
        for (let i = player.bullets.length - 1; i >= 0; i--) {
            const bullet = player.bullets[i];
            bullet.x += bullet.vx * dt;
            bullet.y += bullet.vy * dt;
            bullet.lifetime -= dt;
            
            // Check collision with enemies
            for (const enemy of enemies) {
                if (enemy.collidesWith(bullet)) {
                    enemy.takeDamage(bullet.damage);
                    player.bullets.splice(i, 1);
                    spawnParticles(bullet.x, bullet.y, 8, '#00ffff', 60, 2, 0.5, 0);
                    break;
                }
            }
            
            // Check collision with platforms
            for (const platform of platforms) {
                if (bullet.x < platform.x + platform.width &&
                    bullet.x + bullet.width > platform.x &&
                    bullet.y < platform.y + platform.height &&
                    bullet.y + bullet.height > platform.y) {
                    player.bullets.splice(i, 1);
                    spawnParticles(bullet.x, bullet.y, 5, '#00ffff', 40, 2, 0.5, 0);
                    break;
                }
            }
            
            // Remove if lifetime expired
            if (bullet.lifetime <= 0) {
                player.bullets.splice(i, 1);
            }
        }
    }
    
    // Ambient particles
    if (Math.random() < 0.05) {
        spawnParticles(
            camera.x + Math.random() * canvas.width,
            camera.y + Math.random() * canvas.height,
            1, 'rgba(100, 100, 150, 0.5)', 10, 2, 3, 5
        );
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Background
    drawBackground(ctx);
    
    if (currentState === GameState.PLAYING || currentState === GameState.PAUSED) {
        // Ambient lighting first (under everything)
        drawAmbientLighting(ctx, camera);
        
        // Level elements
        drawPlatforms(ctx, camera);
        drawHazards(ctx, camera);
        
        // Interactables
        interactables.forEach(i => i.draw(ctx, camera));
        
        // Goal
        drawGoal(ctx, camera);
        
        // Racers
        racers.forEach(r => r.draw(ctx, camera));
        
        // Enemies
        enemies.forEach(e => e.draw(ctx, camera));
        
        // Draw boss spears
        for (const enemy of enemies) {
            if (enemy.spears) {
                for (const spear of enemy.spears) {
                    const screenX = spear.x - camera.x;
                    const screenY = spear.y - camera.y;
                    
                    // Spear projectile
                    ctx.fillStyle = Colors.stone;
                    ctx.fillRect(screenX, screenY, spear.width, spear.height);
                    
                    // Spear tip
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(screenX + spear.width - 4, screenY - 2, 4, 2);
                }
            }
        }
        
        // Draw player bullets
        if (player.bullets) {
            for (const bullet of player.bullets) {
                const screenX = bullet.x - camera.x;
                const screenY = bullet.y - camera.y;
                
                // Player bullet with glow effect
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 8;
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(screenX, screenY, bullet.width, bullet.height);
                ctx.shadowBlur = 0;
                
                // Bullet trail (fixed direction)
                const trailDirection = bullet.vx > 0 ? -1 : 1;
                ctx.fillStyle = 'rgba(0, 255, 255, 0.3)';
                ctx.fillRect(screenX + trailDirection * 10, screenY + 1, 10, bullet.height - 2);
            }
        }
        
        // Player
        player.draw(ctx, camera);
        
        // Particles (on top)
        drawParticles(ctx, camera);
        
        // Race UI
        drawRacePosition(ctx);
        
        // Vignette
        const vignette = ctx.createRadialGradient(
            canvas.width/2, canvas.height/2, canvas.height * 0.3,
            canvas.width/2, canvas.height/2, canvas.height
        );
        vignette.addColorStop(0, 'rgba(0,0,0,0)');
        vignette.addColorStop(1, 'rgba(0,0,0,0.6)');
        ctx.fillStyle = vignette;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
}

function gameLoop(timestamp) {
    deltaTime = Math.min((timestamp - lastTime) / 1000, 0.1);
    lastTime = timestamp;
    
    update(deltaTime);
    draw();
    
    requestAnimationFrame(gameLoop);
}

// ==================== CUTSCENES ====================
const cutscenes = {
    intro: [
        { text: "Deep beneath the surface, in the underground kingdom of ANTHERA, a thriving ant civilization flourished...", speaker: null },
        { text: "Queen Sita, beloved matriarch of the colony, brought prosperity to all who dwelt within the underground tunnels.", speaker: null },
        { text: "But darkness invaded from the depths below...", speaker: null },
        { text: "The rival fire ant colony, led by the ruthless General Ravana, launched a surprise attack through secret tunnels.", speaker: null },
        { text: "They overwhelmed our defenses and captured the Queen, dragging her deep into the forbidden zones.", speaker: null },
        { text: "You are but a young worker ant, yet you alone witnessed their escape route through the ancient passages.", speaker: "NARRATOR" },
        { text: "The underground tunnels... where no light reaches... where ancient horrors dwell...", speaker: "NARRATOR" },
        { text: "Will you descend into darkness to save your Queen and colony?", speaker: "NARRATOR" }
    ],
    level1Intro: [
        { text: "EPISODE I: THE DESCENT", speaker: null, isTitle: true },
        { text: "The entrance to the lower tunnels looms before you, dark and foreboding.", speaker: null },
        { text: "You can hear the distant echoes of fire ant soldiers. They don't expect pursuit from a mere worker.", speaker: null },
        { text: "Navigate through the caverns. Watch for rockfalls and hostile patrols.", speaker: "ELDER ANT" },
        { text: "Your courage gives hope to the entire colony, young one.", speaker: "ELDER ANT" }
    ],
    level1Complete: [
        { text: "You've made it through the first layer of tunnels.", speaker: null },
        { text: "But the path ahead is blocked by the ancient Puzzle Chamber...", speaker: null },
        { text: "The old ones built these mechanisms to guard their most precious secrets.", speaker: null }
    ],
    level2Intro: [
        { text: "EPISODE II: THE PUZZLE CHAMBER", speaker: null, isTitle: true },
        { text: "Before you lies the legendary Puzzle Chamber of the Ancient Ants.", speaker: null },
        { text: "Many have entered. Few have emerged with their sanity intact.", speaker: null },
        { text: "The mechanisms respond to color sequences and pressure. Your ant instincts must guide you.", speaker: null },
        { text: "The fate of our Queen depends on your wit and courage, little one.", speaker: "ANCIENT SPIRIT" }
    ],
    level2Complete: [
        { text: "Incredible... you've solved the ancient puzzles that guard our realm.", speaker: null },
        { text: "But wait - fire ant reinforcements! They've found another way through!", speaker: null },
        { text: "You must outrun them to reach the Queen's location first!", speaker: null }
    ],
    level3Intro: [
        { text: "EPISODE III: THE RACE THROUGH DARKNESS", speaker: null, isTitle: true },
        { text: "Fire ant soldiers flood the tunnels behind you!", speaker: null },
        { text: "There's only one path forward - and they're taking it too.", speaker: null },
        { text: "Race through the underground passages. Use your agility to outmaneuver them!", speaker: null },
        { text: "The Queen's life depends on your speed, brave worker ant!", speaker: null }
    ],
    level3Complete: [
        { text: "You've outpaced them! The fire ant fortress lies ahead.", speaker: null },
        { text: "But one final challenge awaits...", speaker: null },
        { text: "General Ravana himself guards the Queen in his throne room.", speaker: null },
        { text: "Prepare yourself for the battle that will determine our colony's fate.", speaker: null }
    ],
    bossIntro: [
        { text: "FINAL EPISODE: THE THRONE ROOM CONFRONTATION", speaker: null, isTitle: true },
        { text: "So... a single worker ant dares to challenge me?", speaker: "GENERAL RAVANA" },
        { text: "I've crushed entire colonies beneath my feet. What chance do you have?", speaker: "GENERAL RAVANA" },
        { text: "Your Queen watches from her cage. Let her see your futile sacrifice!", speaker: "GENERAL RAVANA" },
        { text: "For Anthera! For Queen Sita! For the colony!", speaker: "YOU" }
    ]
};

let currentCutscene = null;
let cutsceneIndex = 0;
let cutsceneCallback = null;
let typewriterText = '';
let typewriterIndex = 0;
let typewriterTimer = 0;

function playCutscene(name, callback) {
    currentCutscene = cutscenes[name];
    cutsceneIndex = 0;
    cutsceneCallback = callback;
    currentState = GameState.CUTSCENE;
    
    document.getElementById('cutsceneOverlay').style.display = 'flex';
    document.getElementById('hud').style.display = 'none';
    
    showCinematicBars(true);
    showCutsceneSlide();
}

function showCutsceneSlide() {
    if (cutsceneIndex >= currentCutscene.length) {
        endCutscene();
        return;
    }
    
    const slide = currentCutscene[cutsceneIndex];
    
    if (slide.isTitle) {
        document.getElementById('cutsceneText').innerHTML = `
            <h2 style="font-size: 1.2rem; color: #888; letter-spacing: 5px; margin-bottom: 10px;">
                ${slide.text.split(':')[0]}
            </h2>
            <h1 style="font-family: 'Uncial Antiqua', cursive; font-size: 2.5rem; color: #ffd700; text-shadow: 0 0 20px #ff6b00;">
                ${slide.text.split(':')[1] || ''}
            </h1>
        `;
        document.getElementById('cutsceneImage').innerHTML = '';
    } else {
        // Typewriter effect
        typewriterText = slide.text;
        typewriterIndex = 0;
        document.getElementById('cutsceneText').textContent = '';
        
        if (slide.speaker) {
            document.getElementById('cutsceneImage').innerHTML = `
                <div style="color: ${slide.speaker === 'GENERAL RAVANA' ? '#ff4444' : '#ffd700'}; 
                            font-size: 1.5rem; text-align: center;">
                    ${slide.speaker}
                </div>
            `;
        } else {
            document.getElementById('cutsceneImage').innerHTML = `
                <div style="color: #666; font-size: 1rem;">‚ú¶ ‚ú¶ ‚ú¶</div>
            `;
        }
    }
}

function updateTypewriter(dt) {
    if (currentState !== GameState.CUTSCENE || !typewriterText) return;
    
    typewriterTimer += dt;
    if (typewriterTimer > 0.03 && typewriterIndex < typewriterText.length) {
        typewriterTimer = 0;
        typewriterIndex++;
        document.getElementById('cutsceneText').textContent = 
            typewriterText.substring(0, typewriterIndex);
    }
}

function advanceCutscene() {
    if (typewriterIndex < typewriterText.length) {
        // Skip to end of current text
        typewriterIndex = typewriterText.length;
        document.getElementById('cutsceneText').textContent = typewriterText;
    } else {
        cutsceneIndex++;
        showCutsceneSlide();
    }
}

function endCutscene() {
    document.getElementById('cutsceneOverlay').style.display = 'none';
    showCinematicBars(false);
    
    if (cutsceneCallback) {
        cutsceneCallback();
    }
}

function showCinematicBars(show) {
    const height = show ? '60px' : '0';
    document.getElementById('topBar').style.height = height;
    document.getElementById('bottomBar').style.height = height;
}

// ==================== GAME FLOW ====================
function showTitleScreen() {
    currentState = GameState.MENU;
    document.getElementById('loading').style.display = 'none';
    document.getElementById('titleScreen').style.display = 'flex';
    document.getElementById('hud').style.display = 'none';
    document.getElementById('controls').style.display = 'none';
}

function startGame() {
    document.getElementById('titleScreen').style.display = 'none';
    playCutscene('intro', () => startLevel(1));
}

function startLevel(level) {
    currentLevel = level;
    currentState = GameState.PLAYING;
    
    // Reset UI
    document.getElementById('hud').style.display = 'flex';
    document.getElementById('controls').style.display = 'block';
    document.getElementById('levelComplete').style.display = 'none';
    document.getElementById('gameOver').style.display = 'none';
    document.getElementById('bossHealth').style.display = 'none';
    document.getElementById('puzzleUI').style.display = 'none';
    document.getElementById('racePosition').style.display = 'none';
    document.getElementById('timer').style.display = 'none';
    document.getElementById('healthFill').style.width = '100%';
    
    // Level-specific UI
    const levelNames = ['', 'The Descent', 'The Puzzle Chamber', 'The Race', 'The Confrontation'];
    document.getElementById('levelName').textContent = `EPISODE ${['', 'I', 'II', 'III', 'IV'][level]}`;
    document.getElementById('levelSubtitle').textContent = levelNames[level];
    
    if (level === 2) {
        document.getElementById('puzzleUI').style.display = 'block';
    }
    if (level === 3) {
        document.getElementById('racePosition').style.display = 'block';
        document.getElementById('timer').style.display = 'block';
    }
    
    // Show episode title
    const episodeTitle = document.getElementById('episodeTitle');
    episodeTitle.querySelector('h2').textContent = `EPISODE ${['', 'I', 'II', 'III', 'FINAL'][level]}`;
    episodeTitle.querySelector('h1').textContent = levelNames[level];
    episodeTitle.style.display = 'block';
    episodeTitle.style.opacity = '1';
    
    setTimeout(() => {
        episodeTitle.style.opacity = '0';
        setTimeout(() => {
            episodeTitle.style.display = 'none';
        }, 500);
    }, 2000);
    
    // Create level
    createLevel(level);
    
    // Play level intro
    const intros = ['', 'level1Intro', 'level2Intro', 'level3Intro', 'bossIntro'];
    playCutscene(intros[level], () => {
        currentState = GameState.PLAYING;
        document.getElementById('hud').style.display = 'flex';
    });
}

function levelComplete() {
    currentState = GameState.LEVEL_COMPLETE;
    
    // Play completion cutscene
    const completes = ['', 'level1Complete', 'level2Complete', 'level3Complete'];
    
    if (currentLevel < 4) {
        playCutscene(completes[currentLevel], () => {
            document.getElementById('levelComplete').style.display = 'flex';
            document.getElementById('completeMessage').textContent = 
                currentLevel === 3 ? 'The final battle awaits...' : 'Prepare for the next challenge.';
        });
    }
}

function continueToNextLevel() {
    document.getElementById('levelComplete').style.display = 'none';
    startLevel(currentLevel + 1);
}

function gameOver() {
    currentState = GameState.GAME_OVER;
    document.getElementById('gameOver').style.display = 'flex';
    document.getElementById('hud').style.display = 'none';
    camera.addShake(10, 0.5);
}

function victory() {
    currentState = GameState.VICTORY;
    document.getElementById('bossHealth').style.display = 'none';
    document.getElementById('hud').style.display = 'none';
    
    // Epic victory effects
    camera.addShake(15, 1);
    for (let i = 0; i < 100; i++) {
        setTimeout(() => {
            spawnParticles(
                player.x + Math.random() * 200 - 100,
                player.y + Math.random() * 200 - 100,
                5, Colors.gold, 150, 4, 2, -50
            );
        }, i * 50);
    }
    
    setTimeout(() => {
        document.getElementById('victory').style.display = 'flex';
    }, 2000);
}

function retryLevel() {
    document.getElementById('gameOver').style.display = 'none';
    startLevel(currentLevel);
}

function returnToMenu() {
    document.getElementById('gameOver').style.display = 'none';
    document.getElementById('victory').style.display = 'none';
    showTitleScreen();
}

function showStory() {
    playCutscene('intro', showTitleScreen);
}

// ==================== EVENT LISTENERS ====================
document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('storyBtn').addEventListener('click', showStory);
document.getElementById('controlsBtn').addEventListener('click', showControls);
document.getElementById('aboutBtn').addEventListener('click', showAbout);
document.getElementById('closeControls').addEventListener('click', hideControls);
document.getElementById('closeAbout').addEventListener('click', hideAbout);
document.getElementById('continueBtn').addEventListener('click', continueToNextLevel);
document.getElementById('retryBtn').addEventListener('click', retryLevel);
document.getElementById('menuBtn').addEventListener('click', returnToMenu);
document.getElementById('creditsBtn').addEventListener('click', returnToMenu);
document.getElementById('skipBtn').addEventListener('click', endCutscene);

// Modal functions
function showControls() {
    document.getElementById('controlsModal').style.display = 'flex';
}

function hideControls() {
    document.getElementById('controlsModal').style.display = 'none';
}

function showAbout() {
    document.getElementById('aboutModal').style.display = 'flex';
}

function hideAbout() {
    document.getElementById('aboutModal').style.display = 'none';
}

// Cutscene advance
document.addEventListener('keydown', (e) => {
    if (e.code === 'Space' && currentState === GameState.CUTSCENE) {
        advanceCutscene();
    }
});

document.getElementById('cutsceneOverlay').addEventListener('click', () => {
    if (currentState === GameState.CUTSCENE) {
        advanceCutscene();
    }
});

// ==================== INITIALIZATION ====================
function init() {
    // Simulate loading
    setTimeout(() => {
        Assets.loaded = true;
        showTitleScreen();
    }, 2000);
    
    // Start game loop
    requestAnimationFrame(gameLoop);
    
    // Typewriter update
    setInterval(() => {
        updateTypewriter(0.016);
    }, 16);
}

init();
    </script>
</body>
</html>
